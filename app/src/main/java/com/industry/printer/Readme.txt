2024-12-18 241218-133000001
==================
临时IDS_INDEX = 0

2024-12-18 241218-132900001
==================
monitorThread中暂时取消pd_set_temperature_override，可能引起14号错误

2024-12-18 241218-132800001
==================
Java_com_pd_get_print_head_status函数中，如果state和error返回错误，但是函数本身没有发挥错误，也给ERR_STRING设置错误信息

2024-12-18 241218-132700001
==================
优化ControlTabActivity.java类中refreshInk函数的处理，先读取getLocalInk，然后再读取getLocalInkPercentage，否则可能在初始化完成后，getLocalInkPercentage还是参照旧值来计算，得出错误结果

2024-12-11 241211-132600001
==================
1. 更新4，5x5，7号字体
2. 对于特殊用户的特殊处理，当最大值为某个值时，不做减锁处理，相当于锁值永远更有效（RFIDDevice.java）

2024-12-11 241211-132500001
==================
22mm，墨水最大值的定位原则：由于根据实验，4列同时打印，打印200次的时候，使用了全部775ml中的10ml，因此，最大值设置为15500会与实际情况同步。同时考虑到可能会有1列单独，2列，3列打印的情况，因此将最大值按1列打印为标准设置，乘以4。
同时，getLocalInk的时候，根据实际使用的列数，将以1列数据为标准的锁值计数按列数缩小后返回；downLocal的时候，根据列数减记次数放大

2024-12-10 241210-132400001
==================
22mm，内部锁值最大值设为15500，对应于最大墨量775ml

2024-12-10 241210-132300001
==================
22mm，内部锁值最大值设为16120，这样会与全部墨量为806克的进度（实测内部打印计数为200时，消耗10g墨水）同步

2024-12-10 241210-132200001
==================
22mm本来应该使用内部的统计系统统计墨水的消耗情况，但是暂时看似乎没有动作，因此启用独自的统计系统，计数值保存在OEM_RW区域

2024-12-9 241209-132100001
==================
将240907-131200001版本中修改的横向扩展缩小为原来的1/3 (1056*1056 -> 352*1056)改为缩小到1/4 (352*1056 -> 264*1056)

2024-12-6 241206-142000001
==================
修改hp22mm库。在1.0.114的基础上，增加pd_disable_warming，并且将这两个调用同时放在守护线程中调用

2024-12-6 241206-141900001
==================
修改hp22mm库。取消1.0.108之后进行的左右尝试，改为在上电（pd_power_on）成功后强制关闭加热功能（pd_set_temperature_override, 暂时不用pd_disable_warming）

2024-12-6 241206-141800001
==================
修改DM码的生成方法，在生成DM码时就按四边缩小一个像素的方式生成

2024-11-25 241125-141700001
==================
模式的切换取消代码中的硬码设置模式，改为参数。
增加两个参数，参数95=小卡自有天线模式启动标识，0=正常模式；1=小卡自有天线模式。参数96=小卡自由天线模式加墨阈值，缺省0=310；其余值=实际值(正常模式时，加墨阈值仍为138)
参数修改后需要重启生效

2024-11-20 241120-141600001(Prv)
==================
241120-141500001的自有天线小锁版

2024-11-20 241120-141500001
==================
1. smartcard库中，所有的I2C访问，完成后均将I2C修正到BULK1(IDS)
2. 修改arial和romantic字库

2024-11-19 241119-141400001(Prv)
==================
自有小天线版

2024-11-19 241119-141300001
==================
com_smartcard.c中，读完Level后，将I2C切换到墨袋上

2024-11-19 241119-141200001
==================
1. 更新西班牙文array.xml和string.xml
2. 追加arial和romantic两种字体

2024-11-16 241116-141100001
==================
1.0.111增加的enable_warming前再加上set_temperature_override函数

2024-11-15 241115-141000001
==================
取消1.0.111的修改，不再设目标温度，取消pd_calibrate_pulsewidth，在守护线程中增加enable_warming和测温函数

2024-11-15 241115-140900001
==================
取消1.0.109的修改，添加在power_on时设置目标温度为55度

2024-11-15 241115-140800001
==================
取消守护线程中get_print_head_status返回15号错误后的尝试power_on

2024-11-15 241115-140700001
==================
取消241115-140600001修改。pd_power_on时调用pd_calibrate_pulsewidth

2024-11-15 241115-140600001
==================
守护线程中追加一个测温的功能，用来检测出现15号错误的时候是什么温度

2024-11-14 241114-140500001
==================
先判断SlotA和B哪个没清洗，没清洗的清洗

2024-11-14 241114-140400001
==================
清洗SlotB两次，再清洗A两次

2024-11-14 241114-140300001
==================
暂时仅清洗SlotB

2024-11-14 241114-140200001
==================
清洗SlotA两次，再清洗B两次

2024-11-14 241114-140100001
2024-11-14 241114-140000001
==================
暂时先清洗B，再清洗SlotA

2024-11-14 241114-139900001
==================
暂时仅清洗SlotA

2024-11-14 241114-139800001
==================
暂时不清洗SlotA

2024-11-14 241114-139700001
==================
hp22mm.c中恢复清洗SlotA和B，并且清洗时不停止守护线程

2024-11-13 241113-139600001
==================
hp22mm.c中修改为只清晰SlotB，似乎SlotA没有

2024-11-13 241113-139500001
==================
优化241113-139400001版本

2024-11-13 241113-139400001
==================
增加22mm的purge功能（在测试页面调用）

2024-11-12 241112-139300001
==================
再临时取消_pd_fpga_setreset( instance, 1);

2024-11-12 241112-139200001
==================
临时取消_pd_fpgaflash_writeprotect

2024-11-12 241112-139100001
==================
修改FPGA.s19升级处理。
1. 在apk中，当升级PD，IDS或FPGA的固件时，停止Hp22mmSCManager类的守护线程（互斥）
2. 在hp22mm.c中，为防止pd未初始化，执行强制的初始化

2024-11-12 241112-139000001
==================
hp22mm.c, 修改守护线程bug

2024-11-11 241111-138900001
==================
hp22mm.c中的守护线程变量MonitorThread与ids.c中的变量重名，编译没问题，我这里执行也没问题，但是在其它机器上有问题，更改变量名称为sMonitorThread，避免重名

2024-11-11 241111-138800001
==================
修改hp22mm.c，使得当升级IDS，PD或者FPGA固件时，让守护线程避让

2024-11-11 241111-138700001
2024-11-11 241111-138600001
==================
添加一些log输出

2024-11-11 241111-138500001
==================
由于PD上电时经常会出现58号错误，因此恢复在初始化的时候上电

2024-11-10 241110-138400001
==================
修改Hp22mm的库(hp22mm.c)中的守护线程及相关功能，暂时用编译开关MOD20241110切换原来代码和新修改代码，待功能确认无误后，全部移至新代码。同时对apk的代码也做了修改（以2024-22-10为关键字在代码中查找）。主要功能：
1. 开机初始化时，加压异步处理，不等待
2. 开机时PD不上电，开始打印时上电，停止打印下电
3. 守护线程不在随上电启动，而是在初始化时启动，管理压力和上电情况
4. 在异步加压过程中，守护线程监视加压过程，如果规定时间内压力未达到规定水报错
5. 加压成功后定时监视压力状况，当压力低于预定值时报错，并且尝试重新加压（新功能）
6. 上电成功后的IDS与PD数据交互进程中，如果出现异常向apk报错（新功能），如果时PD-OFF，则尝试再次上电（新功能）
7. 通过测试页面手动加压，减压，上电，下电操作仍然为手动过程。
主要要达到的目的是：
1. 开机初始化没有长时间的等待
2. 出错有再尝试和报错功能

2024-11-9 241109-138300001
==================
取消241109-138000001 - 241109-138200001的临时修改。恢复设置参数保存是的所有操作，但是对于BLE的操作，需要在RFID或者N_RFID的时候才有效，否则不操作蓝牙

2024-11-9 241109-138200001
2024-11-9 241109-138100001
2024-11-9 241109-138000001
==================
取消241109-137900001的修改，当OK的时候，仅限制参数下发。

2024-11-9 241109-137900001
==================
暂时注释掉参数设置保存的操作。

2024-11-9 241109-137800001
==================
取消241109-137700001的修改。将SECURE_INK_POLL_SEC恢复为20，取消对INK_POLL_SEC及SECURE_INK_POLL_SEC的检查，即，每秒都全部执行一遍

2024-11-9 241109-137700001
==================
取消241108-137600001修改，恢复到B115200。将SECURE_INK_POLL_SEC修改为2，提高IDS与PD的数据交换频率，已排除是否为该交换有问题

2024-11-8 241108-137600001
==================
取消1375和1374的尝试内容。串口速率改为B9600再看一下

2024-11-8 241108-137500001
2024-11-8 241108-137400001
==================
uart.c的uart_send函数中，在第40次至第45次写操作时，修改报文，制造错误，看底层反应

2024-11-7 241107-137300001
==================
_print_thread当中读ids_get_supply_status后，输出supply_status.consumed_volume, supply_info.usable_vol的log，以便确认

2024-11-7 241107-137200001
2024-11-7 241107-137100001
==================
修改hp22mm库的一些函数，以便测试出现UART通讯时TIMEOUT的情况。

2024-11-7 241107-137000001
==================
修改hp22mm.c中Java_com_pd_get_print_head_status函数中的条件判断，解除仅PH_STATE_PRESENT或者PH_STATE_POWERED_OFF才返回成功的约束，此约束是将该函数的调用视为开机时的初始化，而不是平时调用

2024-11-6 241106-136900001
==================
合并对应A133平台的功能，修改的地方比较多，以"2024-11-" 或 "A133" 为关键字检索源代码查询

2024-11-2 241102-136800001
==================
修改为显示错误次数

2024-11-2 241102-136700001
==================
临时取消hp22mm的开机初始化

2024-11-2 241102-136600001
==================
hp22mm测试追加一个PD_Power_OnOff试验，具体内容参照代码注释

2024-10-30 241030-136500001
==================
更新俄文arrays.xml文件

2024-10-30 241030-136400001
2024-10-30 241030-136300001
==================
测试9555A的临时版本，统计误码率

2024-10-30 241030-136200001
2024-10-30 241030-136100001
2024-10-30 241030-136000001
2024-10-29 241029-135900001
2024-10-29 241029-135800001
==================
测试9555A的临时版本，无意义

2024-10-28 241028-135700001
==================
smartcard.1.0.404
增加一个9555A读取500次的试验。以及在TestMain类中增加该测试项目

2024-10-28 241028-135600001
==================
hp22mm.so.1.0.086
 _print_thread中放开ids_get_supply_status函数的调用，否则可能会不能实时更新状态数据，尤其是supply_status的consumed_volume不被更新

2024-10-28 241028-135500001
==================
在GraphicObject类中追加一个setWidth的空函数，目的是禁止重新计算宽度，否则会根据路径名计算宽度，与图片无关，导致失真

2024-10-25 241025-135400001
==================
优化DM矩形码的大小比例，改为8*18，此为最优解

2024-10-24 241024-135300001
==================
增加对DM码的矩形码生成的支持。具体修改内容为：
1. 在ObjectInfoDialog类中，追加有关设置正方形和矩形的选择功能，以及与BarcodeObject类的联动
2. 在BarcodeObject类中，增加对DM码的不同种类的支持
3. 支持文件的读和写
4. 【注意】在16点中，由于空间太小，生成的打印缓冲区会发生变形
   DM正方形码和QR码的最小尺寸是21x21，因此在16点中和被切掉右面的一部分；DM的矩形码是由于显示软件的噪音所致，而非码本身的问题
使用方法：在添加变量的对话窗中，当条码种类选择DM的时候，会出现DM码种类的选择项，根据需要选择即可

2024-10-24 241024-135200001
==================
在FpgaGpioOperation类中的init函数中，增加两条
        startPhoEncTest();
        stopPhoEncTest();
目的是使得img当中过滤掉多余的PH14中断，否则开始打印后，会收到一个多余的PH14中断

2024-10-22 241022-135100001
==================
修改241022-135000001版本BUG

2024-10-22 241022-135000001
==================
在扫描协议7的时候，增加对编辑内容进行以#为分隔符的分割，分割后的部分分别保存到不同的桶里，应用于相应index的DT中

2024-10-17 241017-134900001
==================
优化蓝牙功能。在串口通讯出现异常的时候，避免掉已经初始化成功的蓝牙模块再次被初始化。同时完善PDA专用apk的功能，当PDA主动发起与设备的通讯时，如果串口被RFID占用，则无法接收到回复（正常情况下一定会接收到回复），则在接受结果显示区显示红字的Timeout。

2024-10-15 241015-134800001
==================
在MainActivity中追加一个将设置了翻转的非3.5寸屏强制恢复为正向的功能

2024-10-15 241015-134700001
==================
1. 屏幕反转（参数P73）修改为只对3.5寸屏有效，具体的img类型为NNG3，ONG3，GZJ，NSM2
2. PHO-ENC测试的采样间隔改为100ms

2024-10-15 241015-134600001
==================
修改241014-134500001版本bug

2024-10-14 241014-134500001
==================
追加一个测试项目：PHO-ENC TEST。位于测试页面的首层页面的最下面选项。该测试功能的主要内容是：
在不处于打印状态下，使用PH14接收PHO的触发次数，PH15接收ENC的触发次数

2024-10-14 241014-134400001
==================
1. 在DataTransferThread类中，PrintTask的run函数内处理下发数据部分（从pollState开始到所有数据下发完成位置）均采用synchronized (DataTransferThread.class)进行线程保护，同时，对于从串口或者网络接收数据的处理也使用同样办法保护，以避免两者之间相互影响，使得跨线程变量mNeedUpdate发生混乱而导致处理流程发生混乱
2. 解决蓝牙通讯接收到PDA数据时，出现null的问题（如：000B|0000|650|1null2-240807,1.5,B,L1B-04,,,,,,,|0|0nullnull000|0|0008|0D0A）。由于蓝牙通讯是一段一段接收到的，因此中途可能会出现没有数据的情况，此时并不是接收到""，而是接收到null

2024-10-12 241012-134300001
==================
PCCommandHandler类中的work函数读数据后休眠10ms，否则该线程会非常占用CPU，在蓝牙模式下会一直占用CPU，导致RFID无法访问

2024-10-12 241012-134200001
==================
当PDA扫码的二维码无法获得合法数据时，如果强行向apk返回数据，则会返回只有都好的空数据（",,,,,,,,,,"），这会导致分割后无法获得数组，导致setRemote1TextSeparated函数访问数据越界崩溃。修改为：
1. PhoneApp的getDataFromPowerChinaWeb函数，如果无法获得合法数据，返回null，这样可以避免PDA向apk发送数据
2. 在apk端的setRemote1TextSeparated函数中，对可能越界的数据进行保护。

2024-10-11 241011-134100001
==================
优化CounterObject类中对于步长细分功能的实现方法，清理计数逻辑。并且可以通过主控界面的细分计数点击进入细分计数修改功能清零

2024-10-9 241009-134000001
==================
修改241009-133900001版本中修改1的bug

2024-10-9 241009-133900001
==================
1. 当计数器索引为9（即最后一个计数器）时，无论计数细分为何值，均不考虑而直接修改计数
2. GetAndProcessInkUse函数中，当执行失败时，使用的exit函数没有更改为return，导致发生失败时进程整体退出，貌似apk崩溃

2024-10-8 241008-133800001
==================
临时测试接收到串口数据后，打印守护进程是否正常工作的版本。在240929-133700001基础上增加了几条log输出

2024-9-29 240929-133700001
==================
临时测试接收到串口数据后，打印守护进程是否正常工作的版本（同时监视mNeedUpdate变量）

2024-9-29 240929-133600001(Prv)
==================
com_smartcard.c中初始化Level的时候，指定时钟信号源使用外部，多处追加语句：
    config |= CONFIG_REF_CLOCK_SRC

2024-9-28 240928-133500001
==================
串口数据快速发送过来时（即看到画面提示接收到串口数据就触发），会在多次打印后，出现一个数据掉落的情况，分析是由于
mNeedUpdate变量没有volatile，改成
	public volatile boolean mNeedUpdate=false;

2024-9-28 240928-133400001
==================
修改hp22mm库中的打印头监视进程(_print_thread)的实现方法，尽量贴近例子的实现。

2024-9-26 240926-133300001
==================
修改240926-133200001版的bug

2024-9-26 240926-133200001
==================
1. 固定240926-133100001的修改
 1.1. apk方面，将原来开始打印时执行pd_power_on，开启打印监视线程，改为初始化时执行。并且，停止打印时也不再pd_power_off，也不关闭打印监视线程
 1.2. 生成监视打印线程时检查线程是否存在，如果存在就不再生成，主要是为了防止多次初始化时会生成多个线程
 1.3. 将原来的_startPrint和_stopPrint函数改名为pdPowerOn和pdPowerOff
2. 在Hp22mm类中，新增加一个mInitialize变量，用来记忆初始化状态。在点按开始打印时，判断Hp22mm.mInitialized是否为true，时则启动打印，否则停止打印

2024-9-26 240926-133100001
==================
临时将22mm的开始打印时的power_on操作和停止打印时的操作取消。power_on的操作改为初始化时执行

2024-9-23 240923-133000001
==================
扫描协议7的接收画面，修改为全屏上部显示，点按其他部分对话窗不消失。

2024-9-21 240921-132900001
==================
扫描协议7修改，当选择反向打印的时候，不仅左右镜像，并且每个头都单独上下颠倒

2024-9-21 240921-132800001
==================
修改240921-132700001的bug

2024-9-21 240921-132700001
==================
追加一个显示FPGA驱动状态的功能，当前只显示跳空次数(需要img的支持，img需要3175及以后的版本)

2024-9-21 240921-132600001
==================
修改240920-132500001的bug

2024-9-20 240920-132500001
==================
240920-132400001中对打印方向的修改。
如果点按反向打印，则对原来根据参数2打印方向和各个头的打印方向选定的打印方向再进行反转。

2024-9-20 240920-132400001
==================
1. 在MainActivity类中的onKeyDown函数，将61（TAB键值）强制修改为62（空格键值），否则的话，TAB键值会被忽略，导致空格被丢弃的视觉现象
2. 为扫描协议7的扫描信息修改窗增加4个打印头选择按键和一个打印方向选择按键。
   打印头选择按键点按后，在绿色和灰色之间切换，标识选中和未选中，缺省为选中。未选中的打印头打印内容清空
   反向打印按键点按后，在绿色和灰色之间切换，标识反向打印和正常打印，缺省为正常打印。当选择反向打印后，参数中选择的打印方向P2，和每个打印头的镜像设置均失效
   选择状态只在当次上电运行中有效，在重新开机后恢复缺省值。

2024-9-19 240919-132300001
==================
MainActivity类中的onKeyDown函数，修改为返回true，以避免键盘事件继续下发。如果继续下发，会在扫码的时候，某些特殊的码（包含0x3d，解释为CR(0x0d))会自动打开其它的控件

2024-9-19 240919-132200001
==================
在activity_main.xml中再追加一个dummy的控件msg_transfer2，用来截获扫码枪发出的无意义按键事件，否则在有些特殊的条码的时候，会由扫码时间触发transfer按键被按下事件，导致transfer窗口被自动打开

2024-9-18 240918-132100001(Prv)
==================
1. 恢复访问SC卡(240915-132000001)
2. 恢复读Level(240914-131900001)
3. ko版本号增加为显示3位

2024-9-15 240915-132000001(Prv)
==================
临时不访问SC卡的版本

2024-9-14 240914-131900001(Prv)
==================
暂时不读Level的版本做测试

2024-9-14 240914-131800001(Prv)
==================
240914-131700001版的自有天线小卡版

2024-9-14 240914-131700001
==================
临时版本，去掉都电池存量的功能，调整读Level的位置，放在下发了打印数据之后。看看4FIFO的数据中断是否还存在

2024-9-12 240912-131600001
==================
取消240407-120900001版本中追加的，22mm设置img的fpga-sunxi驱动中的左右镜像反转。因为这个可以通过在FPGA内部通过设置寄存器实现。如果通过img来做的话，会与FPGA内部的反转重复，导致最终又反转回来的问题

2024-9-10 240910-131500001
==================
1. 参数78和79修改名称
    C78 = Air pressure
    C79 = Bluetooth
2. 增加16DOTX4头类型。该头类型的特点是：
   2.1 在倾斜(SLANT)处理时，普通的倾斜是按着以shift为步长，每增加一行向后倾斜shift列。但是16DOTX4头的时候，每次倾斜16行后，再归零，从头开始倾斜
   2.2 其余动作与64DOTONE类型一致

2024-9-9 240909-131400001(Prv)
==================
临时版本，自有天线小卡版本

2024-9-7 240907-131300001
==================
在DataTask的getPrintBuffer函数中，HP22MM的打印任务，不去掉墨位空位，以保证列数一致

2024-9-7 240907-131200001
==================
临时版本，HP22MM打印头的时候，打印缓冲区生成时的横向扩展缩小为原来的1/3 (1056*1056 -> 352*1056)

2024-9-7 240907-131100001
==================
1. 修改R15的计算公式修改遗漏
2. 修改SmartCard的jni库中，com_smartcard.c中的锁值根据ILG值及4个最大值参数调整的计算方法，具体看com_smartcard.c中的注释

2024-9-6 240906-131000001
==================
订正240905-130900001寄存器计算公式中的基础错误

2024-9-5 240905-130900001
==================
修改若干hp22mm的寄存器计算公式

2024-9-5 240905-130800001(Prv)
==================
1. 修改readLevel函数的参数，增加传递最大值和最小值。并且在com_smartcard.c中的readLevel函数中，如果读值小于最小值-100，最大值+100则启动重启
2. Prv代表自由天线小卡版本

2024-9-5 240905-130700001
==================
(源代码标记日期2024-9-4)
增加一个扫描协议（扫描协议7），扫描后，扫描内容作为初始内容显示编辑窗，用户可以手动编辑，确定后，作为打印内容可以直接打印
主要修改是对RemoteMsgPrompt对话窗做了扩充，当为扫描协议7时，显示编辑窗部分，其它扫描协议时，显示提示窗部分。

2024-9-3 240903-130600001
==================
1. 修改22mm的R15，R18，R20，R21的计算公式，如下：
    R15=90M/(C1*(C10*2/(C9*3.14)))
    R18=((C1*2*25.4)/(C9*3.14))/C3
    R20=C4*(C10*2/(C9*3.14))+(C12*150/C3)
    R21=C4*(C10*2/(C9*3.14))+(C11*150/C3)
2. 修改QRReader的init函数中，跳过已处理行的操作，由于RTC无电池时，读到的mRow数值巨大，但实际上文件的行数并不大，此时，mRow没有参考意义，readLine返回null时，判断失败，跳出循环
    if(null == mReader.readLine()) break;

2024-9-3 240903-130500001
==================
修改BUG。
注意，90Mx200会超过整型数的最大值（18,000,000,000 > 0x100000000(4,294,967,296)）,所以，R16的计算公式要先除后乘

2024-9-3 240903-130400001
==================
22mm的寄存器16的计算公式修改。由原来的
R16=90M/(C7/C1)
修改为
当R17=1并且R19=0时
R16=C7*24
否则
R16=90M*C7/C1

2024-9-3 240903-130300001
==================
22mm的寄存器20和21的计算公式修改。由原来的
R20= C2x24+c12
R21= C2x24+c11
改为
R20= C4x24+c12
R21= C4x24+c11

2024-8-31 240831-130200001
==================
在DataTask类中，去除末尾空白部分的处理中，如果去除空白后，列数不足5列的，则至少留5列的数据

2024-8-31 240831-130100001
==================
1. 在SmartCardManager类中增加一个错误值统计和显示的功能（值在120-160之外的话判作错误值）
   【界面显示效果】
   在打印过程当中实时显示的墨位信息提示窗中的最下部，如果有错误值发生，则显示：
   Err: 170, 170, ...
   字样。原墨位值显示位置不变，显示方式为：
   Lvl: 145, 145, ...
   字样
2. 调整Java_com_Smartcard_readLevel的重启条件，原来只有0x0FFFFFFF，扩大到0x00000000也重启。再次修改为138加减100以外的值时重启

2024-8-30 240830-130000001
==================
1. 在BLEDevice类中，将
    PCCommandManager.getInstance().addBLEHandler(mBLEStreamTransport);
    从构造函数中挪到initServer函数中，同时在closeServer函数中，追加
    PCCommandManager.getInstance().addBLEHandler(null);
    调用，使得对于蓝牙数据的处理根据蓝牙的启动与否进行开关。同时也避免了初始化BLEDevice时PCCommandManager.getInstance()为空时发生空指针异常
2. 在DataTask类中，调用expendColumn函数之前，判断列数，如果列数为0（br.getColumnNum()）则不调用，否则会出现除数为0的异常

2024-8-30 240830-129900001
==================
1. 在Hp22mm.java类中，生成设置参数时，寄存器7-14的值修改为132
2. 在DynamicText类中，注释掉以下内容，完全遵照DT桶中的内容，不做任何修改，否则，如果是全部空格，则会由、有取消掉空格后变为空，然后用＃替代的问题
//        if(cnt.trim().isEmpty()) {
//            cnt = getContent();
//        }

2024-8-28 240828-129800001
==================
在RfidSchedule类中，再次修改H21低于最小值或者高于最大值的报警门槛次数，由原来的3次改为10次

2024-8-28 240828-129700001
==================
在RfidSchedule类中，再次修改H21读卡芯片的最小值
最小值： 380 -> 350

2024-8-28 240828-129600001
==================
在control2_frame.xml, control3_frame.xml，control4_frame.xml中tv_start控件后面添加一个ble_state控件。该控件为标准页面（control_frame.xml）中显示蓝牙状态的控件，由于其余控件与标准控件共享代码空间，因此，如果在这几个特殊页面中不追加该控件的话，会导致找不到控件的异常而死机

2024-8-27 240827-129500001
==================
大字机字体增加一个新的字高28。不锁定字体

2024-8-26 240826-129400001
==================
在RfidSchedule类中计算avgLevel时，给的初始值，墨袋时为最大值，但是由于H21的判断是反的，所以需要给最小值

2024-8-26 240826-129300001
==================
最大值： 460 -> 500
开阀条件与传统使用的低于阈值开阀加墨不同，H21的时候是高于阈值的时候开阀加墨
【整体总结】
1. RFID 烧94 ， 则在传感器连续读到高于44，加墨
2. 连续读到高于50，报错， 不加墨
3. 连续读到低于38报错， 不加墨
4. 此项目为H21

2024-8-26 240826-129200001
==================
在RfidSchedule类中，修改H21读卡芯片的最大值，最小值，和调整值
最大值： 460 -> 490
最小值： 400 -> 380
调整值： 306 -> 346

2024-8-26 240826-129100001
==================
在RfidSchedule类中，修改生成显示读墨位结果提示窗的阈值显示，使得无论哪种墨位读取芯片都能够正确显示

2024-8-24 240824-129000001
==================
240823-128900001版本在TestSub中追加一个退出测试循环的log，以方便确认进入和退出的情况

2024-8-23 240823-128900001
==================
修改240819-128800001的bug

2024-8-19 240819-128800001
==================
对于240819-128700001的修改，当使用MCPH21时，Feature由普通的+256改为+306，并且乘以1000，比原来的少乘一位。这样RFID设为124的时候，原来的时候，计算出来为380，H21的时候计算结果是43，因此同样的RFID就可以适用于不同的Level墨位读取芯片了

2024-8-19 240819-128700001
==================
当使用MCPH21时，Feature由普通的+256改为+300，以避免430的阈值无法在RFID当中定义（RFID中只能定义[64,163]）

2024-8-17 240817-128600001(Prv)
==================
240816-128500001(Prv)版本的基础上，追加Level值有效性判断的修改。
普通使用时：介于12000000 - 16000000之间
内部测试版本特殊功能时：介于26000000 - 30000000之间

2024-8-16 240816-128500001(Prv)
==================
内部测试版本特殊功能。(1) 墨盒代替墨袋，(2) 阈值由 138->280 (平时为正常版本)

2024-8-16 240816-128400001
==================
1. 修改Smartcard.c中对MCPH21操作的部分，修改sLevelChipType的定义，原来是只考虑了一个头，现在是4个头动作，因此需要通过数组进行分别管理
2. 修改apk中的RfidSchedule类中Bagink与MCPH21使用一套代码时，原Bagink代码可能带来问题的部分（具体参照代码）
3. 修改TestSub类中测试ADS1115和MCP_H21XXXX的bug，当点按对话窗显示区外的部分，导致对话窗隐藏的时候，停止读取数据，并且关闭对话窗

2024-8-6 240806-128300001
==================
1. 将参数58的内容修改为：Printer ID/设备地址
2. 取消240727-128000001中定义的参数79（蓝牙设备号），改为参照参数58的设备地址。将参数80（蓝牙开关）切换到参数79（蓝牙开关），参数80恢复为保留
3. 增加在Bagink类型的img中，追加一个自动区分墨袋种类（1614还是MCPH21）并且分别处理的机制。具体修改处为：
   3.1 在smartcard.c中追加一个getLevelType函数，用来自动识别是1614还是MCPH21芯片
   3.2 在RfidScheduler类中在判定了不同墨袋种类后，分别读墨袋和管理加墨的操作
   （以上修改的细节部分比较多，具体修改内容参照源码，或者使用git甄别）

2024-7-28 240728-128200001
==================
优化240727-128100001版本的Bug，原来的问题是UTF-8汉字传输时，汉字的多字节占用了多于一个的字节，导致正常数据尾部丢失

2024-7-27 240727-128100001
==================
优化240727-128000001版本功能

2024-7-27 240727-128000001
==================
完善蓝牙功能：
1. 在参数中增加“参数79：蓝牙设备号”和“参数80：蓝牙开关”，每个参数均在确认OK后立即生效
2. 支持手机断开后再次打开广播功能，使得手机可以再次搜索到打印机
3. 手机脱离有效通信范围后，返回通信区间时重新连接
4. 在主页打印按键的左上方设置一个小型的蓝色点，如果蓝牙开启服务，则蓝点显示，否则不显示

2024-7-26 240726-127900001
==================
将240720-127500001版本中，在N_RFIDModuleChecker类中open完串口后对波特率的设置取消。因为这里如果设置了115200的话，在RFIDDevice再次打开串口的时候，会自动以19200进行通讯，这样目标与链路的波特率就不匹配了

2024-7-25 240725-127800001
==================
hp22mm库升级到1.0.082，对应于hp的新的api代码Demo_05_03.
具体增加的功能是
1. New code to set SPI quad-enable bit (NOTE: FOR MACRONIX SPI FLASH ONLY!!)
    Set the Quad SPI enable bit in the status read from status register
    主要是在烧写新的FPGA的FW时，设置SPI的属性。需要注意：
    (1) 需要PD的FW版本先升级到5.3版本，否则可能不动作
    (2) NOTE: FOR MACRONIX SPI FLASH ONLY!!。如果是其他的芯片可能会出现错误
2. 增加pd_enable_warming和pd_disable_warming接口及其它相关辅助代码（但是这个API似乎还没有被真正使用）

2024-7-24 240724-127700001
==================
为特殊用户修改扫描协议2时的处理，去掉对末尾字符与第二个字符的匹配检查

2024-7-20 240720-127600001
==================
增加一个数据源
DATA_SOURCE_BLUETOOTH 	= 34
用来指示接收蓝牙数据（600和650数据协议）

2024-7-20 240720-127500001
==================
1. HardwareJni.so类中增加一个cnvt2FileDescriptor函数，主要目的是用来将整数型的文件号转换为FileDescriptor型文件符，以此来实现对于文件的流访问。
2. 在BLEDevice类中，将以前单独打开一个串口
    mSerialPort = new SerialPort();
    改为使用现有的RFID文件号转化为FD型文件符后访问
3. 将N_RFIDModule类及N_RFIDModuleChecker类中的transfer函数函数移植N_RFIDSerialPort中，提高代码的通用性
4. 将N_RFIDModule类中的setBaudrate函数移到N_RFIDSerialPort中，并且对其功能进行扩充，扩充后的功能是分别尝试通过115200，19200和9600与模块通讯，在成功的通道中，将最终码率设置为预定值
5. 对测试页面中的RFID测试做了扩充，增加支持23卡的百次读取试验

2024-7-18 240718-127400001
==================
BT测试专用版。与240710-127300001的区别是，将BLE服务器初始化的自动重复100次取消，因为这个会影响正常的扫描操作

2024-7-10 240710-127300001
==================
1. 扩充240710-127000001版本增加的RFID测试内容。
   1. 扩充到所有的RFID设备
   2. 测试完整的读取RFID数据共嗯那个
2. 所有对RFID访问的地方
   1. RFIDDevice中的writeCmd函数
   2. N_RFIDModule.java中的transfer函数
   3. N_RFIDModuleChecker.java中的transfer函数
   都增加了与蓝牙访问的排斥功能，及对PI9的操作

2024-7-10 240710-127200001
==================
修改240710-127000001版本bug

2024-7-10 240710-127100001
==================
1. 增加Hp22mm在初始化或者开始、停止打印时出错信息的显示，显示的地方是屏幕右下角电池图标的下方，10sp的字体，由于字体很小，可能需要用放大镜查看。当没有发生错误时不显示任何信息
2. 当打印头数超过6时，暂时跳过6个以上的头的信息的显示，因为，显示头信息的区域只有6个空间，超出部分显示时会发生数组越界异常

2024-7-10 240710-127000001
==================
在测试页面的主页面(TestMain.java)中追加一个RFID的100次读写试验。开始实验以后，如果读写成功则显示黄色的Success提示窗，失败则显示Failed提示窗

2024-7-8 240708-126900001
==================
微调240708-126800001版本

2024-7-8 240708-126800001
==================
把对MSG_SMARTCARD_CHECK_FAILED的处理和对MSG_RFID_CHECK_FAIL的处理物理分开，以便区别报墨盒异常错误时是从哪里来的（按理这两者是不会同时出现的，但是刚才出现了不该出现FAILED时，却出现了这个错误的情况，希望通过这个物理分开来厘清是哪里报的错误）

2024-7-8 240708-126700001
2024-7-8 240708-126600001
==================
微调240708-126500001版本，power_on失败时不显示新追加的错误提示

2024-7-8 240708-126500001
==================
1. hp22mm.c(1.0.081)
   追加一个接口函数getErrString（内部：Java_com_GetErrorString），用来向apk返回开始、停止打印时发生的错误
2. 将读取MCP-H21-xxxx的测试功能移至TestSub.java页面，并且支持4个打印头的读取

2024-7-4 240704-126400001
==================
临时版本，修改了libSmartCard.so库，临时追加了一个读取MCP-H21-xxxx的功能。并且在ControlTabActivity的心跳处理中追加了一个周期性启动读数，并且显示读书结果的功能

2024-7-1 240701-126300001
==================
新增加一个扫描协议（扫描协议6），除分隔符为[:]以外，与扫描协议2完全一样

2024-6-25 240625-126200001
==================
修改240622-126100001版本的修改遗漏。修改为第二个PH14才计数是从3104开始的，因此，需要将3104-3142期间的版本做虚假增1处理，这之前的更旧的版本不需要做此处理
				if(FpgaGpioOperation.getDriverVersion() < 3142 && FpgaGpioOperation.getDriverVersion() >= 3104) {        // 如果是原来的(从3104版开始修改的)第二个PH14才更新打印计数的img

2024-6-22 240622-126100001
==================
由于img在2023-10-15的修改中，将实际的打印计数逻辑做了修改。关键点是，第二次PH14来的时候，才被确认为第一次打印的结束。这样会导致，第一次打印的行为不会被计数。由于客户不方便升级img。因此对apk做了特殊处理：
在DataTransferThread类中，增加一个变量mPrintedCountAhead，这个变量的主要目的是调整打印计数。
当在打印伺服线程中检测打印计数的时候，由原来的直接获得打印计数，修改为直接获得打印计数后，进行调整
//					lastPrintedCount = FpgaGpioOperation.getPrintedCount();
					lastPrintedCount = FpgaGpioOperation.getPrintedCount() + mPrintedCountAhead;
主要目的是解决第一次打印不被计数，同时也要避免非必要计数的问题
然后，在下发数据后，做一下判断
			if(!PlatformInfo.getImgUniqueCode().startsWith("22MM") && !PlatformInfo.getImgUniqueCode().startsWith("4FIFO")) {		// 排除HP22MM和4FIFO，因为这两种img的打印计数机制不同
				if(FpgaGpioOperation.getDriverVersion() < 3142) {        // 如果是原来的第二个PH14才更新打印计数的img
					int fifoSize = SystemConfigFile.getInstance(mContext).getParam(SystemConfigFile.INDEX_FIFO_SIZE) == 0 ? 1 : SystemConfigFile.getInstance(mContext).getParam(SystemConfigFile.INDEX_FIFO_SIZE);
					if(mDownWrittenCount == fifoSize + 1) {		// 当FIFO已经填满（如果FIFO个数为多个，则会出现多个empty，导致下发，但这是下发的数量会保存在FIFO中，并没有立即参与打印），正在下发超出FIFO尺寸的第一个任务时，认为第一次打印已经完成
   						mPrintedCountAhead = 1;
					}
				}
			}
就是当img不是hp22mm或者4FIFO的时候（这两种img的计数方式不同），并且fpga的驱动的版本在3142以下时（3142对计数方式做了调整），并且放过为了填满FIFO所做的预先下发，遇到第一次实际因为触发了打印才进行的下发，做一个调整计数，1，这个计数用来修正从img获得的打印计数
这样就可以避免出现，在打印业务中，触发了一次打印，但是打印计数却不被计数的问题

2024-6-21 240621-126000001
==================
对240620-125900001版本做了优化

2024-6-20 240620-125900001
==================
追加一个22mm通过SPI进行24M速率的写试验。为此，增加命令FPGA_CMD_HP22MM_HI_SPEED_WTEST，同时HP22MM的测试页面中追加相应的菜单选项

2024-6-19 240619-125800001
==================
将RFIDDevice中的connect函数中恢复到调用writeCmd，而不是调用RFIDAsyncTask的execute函数

2024-6-15 240615-125700001
==================
1. 当QR.txt已经到了最后时，再次触发，恢复到2022-4-8 220408-30817版本时的状态，即报警，显示提示，但是不强制停止打印。为了防止过于频繁的报警，在DataTransferThread类中，添加下列代码：
    try { Thread.sleep(1000); } catch (InterruptedException e) {Debug.e(TAG, e.getMessage());}
    continue;
以达到不下发数据，并且每隔1秒钟检查一次empty事件，从而达到每隔1秒钟报警一次的效果
2. SmartCardManager和Hp22mmSCManager类中，当初始化未完成时，getLocalInkPercentage函数中返回50%，避免无意义的报警，也避免100%显得过于好的数值
3. Hp22mm.java类中的initHp22mm函数中，恢复任何一个步骤失败时返回错误码的操作。

2024-6-15 240615-125600001
==================
1. 在Hp22mmSCManager类中追加一个mInitialized变量，用来作为是否初始化成功的标识，如果还没有初始化，则在getLocalInkPercentage函数中返回100%，以避免报警
2. 在ControlTabActivity类中的refreshInk函数中，当ink值恢复正常的时候（有可能出现报警原因接触后，回复正常的情况，当前没有放弃报警的机制）取消报警。
				mHandler.removeMessages(MESSAGE_RFID_LOW);
				mHandler.removeMessages(MESSAGE_RFID_ZERO);

2024-6-15 240615-125500001
==================
修改Hp22mmSCManager类的getLocalInkPercentage函数中，当读到的数值为0时，将mValid设为false的操作，因为可能在初期可能会出现读到的是0的情况。

2024-6-14 240614-125400001
==================
将img的版本号显示文字，有25sp字号改为22sp字号

2024-6-14 240614-125300001
==================
240612-125100001的两处修改进队arrays.xml的英文版做了修改，此次扩充到其他语言版本

2024-6-12 240612-125200001
==================
将240612-125100001中定义的GS1-11，GS1-12和GS1-13数据源名称改为GS1-3， GS1-4， GS1-5

2024-6-12 240612-125100001
==================
1. 追加GS1-1，GS1-2，GS1-3的条码解析功能（由于以前使用大括号的GS1已经使用了GS1-2的名称，因此暂时在数据源选项中使用GS1-11，GS1-12和GS1-13作为选择）。具体内容如下：
// GS1-1 0104607017595534215BD&Tw931ekW
// 其中： 0104607017595534 （16位）。01为AI，04607017595534为数据
// 		 215BD&Tw   （8位）。21为AI，5BD&Tw为数据
// 		 931ekW（6位）。93为AI，1ekW为数据
// GS1-2 0104610011892486215("+BsUbSn&ur91EE0992e6koCrc88wLNV2ksh8GoO/e3yhPdJMYyRNqrJz+Wu4M=
// 其中： 0104610011892486  （16位）。01为AI，04610011892486为数据
//       215("+BsUbSn&ur   （15位）。21为AI，5("+BsUbSn&ur为数据
//       91EE09           （6位）。91为AI，EE09为数据
//       92e6koCrc88wLNV2ksh8GoO/e3yhPdJMYyRNqrJz+Wu4M=    （46位）。92为AI，e6koCrc88wLNV2ksh8GoO/e3yhPdJMYyRNqrJz+Wu4M=为数据
// GS1-3 01xxxxxxxxxxxxxx\21xxxxx\91xxxx\92xxxxxx
// 其中： （1）报文被反斜杠(\)分割成为数段；
//        （2）每段开头为2位数字的AI（其它位数的AI暂不支持）
//        （3）每个AI后面的字符为对应于该AI的数据，数据的合法性需要用户保证，当数据错误时生成条码失败
2. 追加时间格式 DD.MM.YYYY

2024-6-11 240611-125000001
==================
1. 更换7字体
2. 修改西班牙文arrays.cml的switch_item_entries中的on和off的文字

2024-6-7 240605-124900001
==================
单纯版本更新

2024-6-5 240605-124800001
==================
res.res_size返回0时修改为返回错误，原来HP代码未作处理

2024-6-4 240604-124700001
==================
修改了一些hp22mm库中的log输出语句（保持取消Hp22mmSCManager类中开机初始化Hp22mm库的操作，编译后立即恢复）

2024-6-3 240603-124600001
==================
暂时取消Hp22mmSCManager类中开机初始化Hp22mm库的操作。（2024-6-4已恢复）

2024-6-1 240601-124500001
==================
print_head_driver.c 中的 #define FPGA_FLASH_SIZE (2 * 1024 *1024)修改为#define FPGA_FLASH_SIZE (3 * 1024 *1024)

2024-5-31 240531-124400001
==================
1. 修改显示1115读数算法：Vout / 32767 * (4 * 66.67 + 12) - 6.67 (kPa)
2. FSR = ±4.096 V

2024-5-30 240530-124300001
==================
根据计算公式：设置5571时：(P78 + 6.67) / 66.7 / 3.3 * 255)
P78的取值范围：[0,200]，则5571的设置取值范围为[7, 239]。但是当参数78为0时，5571设置为0（特殊处理）。

2024-5-30 240530-124200001
==================
1. 参数78增加单位kPa显示
2. 修改测试1115的页面。只测试和显示AIN0

2024-5-29 240529-124100001
==================
1. com_smartcard.c中的Java_com_Smartcard_readADS1115函数，修改切换输入口的逻辑，以前先读数据然后切换到下一个口，这样在循环读入的时候可以节省时间，并且给都入口一个缓冲时间，以便数据能够稳定。但是，如果每次都是读取一个固定的口，这种逻辑就会导致读错口。
修改为，先切换口，然后休眠10ms，然后再读取数据。
2. 更新西班牙语字符串

2024-5-29 240529-124000001
==================
修改气压计算公式：
设置5571时：(P78 + 6.67) / 66.7 / 3.3 * 255)
显示1115读数时：Vout / 32767 * 3.3 * 66.67 - 6.67 (kPa)

2024-5-28 240528-123900001
==================
主页面增加气压读数显示功能（临时测试版）

2024-5-28 240528-123800001
==================
1115芯片的地址改为0x49

2024-5-27 240527-123700001
==================
临时追加一个DAC5571的设置功能，值从参数中设置，范围为0-255。该值在参数78处设置。

2024-5-24 240524-123600001
==================
240524-123500001的小锁版本（使用墨盒替代墨袋）

2024-5-24 240524-123500001
==================
1. 加墨持续高时长从100ms改为1s
2. 增加ADS1115芯片的读值功能

2024-5-11 240511-123400001
==================
1. 计数器固定四位，0->0000，9999->9999，10000,20000->0000
2. M9测试页面中的测网速和测串口按键中追加转轮，标识正在进行中

2024-5-10 240510-123300001
==================
1. 升级KO的时候，如果MD5值相同也执行升级，返回真
2. 串口协议7追加清洗(CMD_START_PRINT_A)和打印特定文件(CMD_START_PRINT_X)的命令

2024-5-8 240508-123200001
==================
修改240508-123100001版在BaseObject类中setY中对y的最终值的调整，因为在读进TLK文件的时候，mHeight还没有确定（初值设为了152），会导致y的值被调整。修改为对于是否越界的调整放在EditTabSmallActivity类中的upKeyPressed和downKeyPressed函数中进行

2024-5-8 240508-123100001
==================
修改2024-4-30修改2（240506-122400001）的限制上下移越界问题时的bug，由于移动步长为4个点，当不足4个点的时候，因为禁止越界所以禁止移动的话，会导致此时虽然还有空间（虽然不足4点高度），但是无法移动的问题。修改为，如果不足4点，则移动可移动的点数

2024-5-7 240507-123000001
==================
优化切除后部空白的算法，原算法只检测前两个char是否为0，如果64点的话，实际每列是4个char，那么就会错误切掉上部虽然为0，但下部还有数据的部分，导致打印内容后部缺失

2024-5-7 240507-122900001（取消该修改）
==================
64_DOT_ONE喷头类型旋转的时候(SLANT)，每列空出64列的空间，而不是32列

2024-5-7 240507-122800001
==================
64_DOT_ONE喷头类型修改为支持镜像，其余不变

2024-5-6 240506-122700001
==================
修改240506-122600001的修改遗漏

2024-5-6 240506-122600001
==================
禁止左侧移动越界 - BaseObject.java

2024-5-6 240506-122500001
==================
追加16@LB，16@RB字体

2024-5-6 240506-122400001
==================
与240506-122300001版本功能完全一致，只是将墨袋的种类暂时设为小锁（墨盒替代墨袋），以方便内部测试

2024-5-6 240506-122300001
==================
增加开机拉低PE4和PE5

2024-5-2
==================
追加一个FPGA升级的进度查询命令（需要fpga-sunxi.ko3139以上版本的配合）

2024-4-30
==================
1. 修改编辑画面，将非使用区域变成浅灰色 - drawable中的background.png等
2. 对于向上向下移动操作，禁止越界移动 - BaseObject.java
3. 修改PinyinIME的切换语言串口，将原来本应显示中文的按钮却显示成英文的修改为显示中文（该修改涉及PinyinIME.apk，需要更新img时起效）
4. 将参数11，12，19，20，偏移量的上限修改为20000（原值为99999）- params.xml
5. 12.7的缺省字高值中，增加一个0.5的值（原来的值从1.0开始）- MessageObject.java的mBaseList

2024-4-29 240429-122200001
==================
追加64_DOT_ONE喷头类型，特点是不允许平移，不允许镜像，不允许反转，只允许旋转，旋转按着标准方法整体旋转

2024-4-29 240429-122100001
==================
修改240428-122000001的修改遗漏

2024-4-28 240428-122000001
==================
增加3个字体 16X12B，7X6B，10X8B，绑定7B，4B，10B字体。修改涉及MessageObject,BaseObject类和ObjectInfoDialog类

2024-4-24 240424-121900001
==================
在SmartCardManager.java类中执行加墨之前再次读取一次Level的值，如果确实缺墨再加，否则不加。目的是防止欧洲用户有加墨过多的问题

2024-4-22 240422-121800001
==================
取消240422-121700001的修改，改为根据ko的版本号，如果是3119（包括）以后的版本，则按着先下发数据后，后开始打印的处理方式。否则，按着先开始打印，后下发数据的方式处理

2024-4-22 240422-121700001
==================
由于2024-3-25将打印顺序从先开始打印，后下发数据改为先下发数据，后开始打印，导致FpgaGpioOperation类中，通过mJustStartedPrint调整在第一次下发数据后才设置FPGA_STATE_OUTPUT的机制失效。因此，取消该机制，并且在开始打印的init函数中，直接设置FPGA_STATE_OUTPUT状态。

2024-4-19 240419-121600001
==================
hp22mm测试页面增加一个写入大块数据的测试项目

2024-4-18 240418-121500001
==================
对240417-121400001进行修改，虽然使用E5的通道，但是实现逻辑完全照E6做，然后加上新加的类型内容。

2024-4-17 240417-121400001
==================
借用E5X48和E5X50类型，实现新的打印数据构建方法，原有的方法废止。新的类型内容为：
 1. 前部加20列竖线
 2. 整体后移15mm（相当于15*6=90列）
 3. 整体后部相应地切除15mm（相当于15*6=90列）

2024-4-12 240412-121300001
==================
临时修改Hp22mm类，初始化时即使失败也不返回，继续执行后面的步骤

2024-4-9 240409-121200001
==================
DT的桶扩容到32个的修改内容：
1. 当使用网络600命令，或者数据源为FILE的时候，接收到的数据为
   [dt0][dt1] ... [dt10] ... [dt31]
   其中dt0-dt9以及dt11-dt31对应于在每个打印任务中的动态文本(DT)的出现顺序，并且将dt的值付给该DT变量所对应的桶里面保存，留作后续再使用。举例说明：
   如dt0的值，将会付给第一个出现的DT变量，如果这个DT变量的索引为2，则dt0会保存到第2个桶里面。
   dt10固定赋值给条码即相应的桶里面，因此dt9付给第10个DT变量对应的桶，但dt10赋值给条码，dt11则赋值给第11个DT变量对应的桶
2. 当使用网络650命令，或者数据源为FILE2的时候，接收到的数据为
   [dt0][dt1] ... [dt10] ... [dt31]
   其中dt0-dt9以及dt11-dt31直接对应于桶的位置，因此直接更新到桶里面。然后，打印任务使用桶里的值进行打印。举例说明：
   如dt0的值，第1个桶里面。所有的打印任务中，只要是DT变量的索引为0（对应于第1个桶）即使用该值
   dt10固定赋值给条码即相应的桶里面，因此dt9付给第10个桶，但dt10赋值给条码的桶，dt11则赋值给第11个桶

2024-4-8 240408-121100001
==================
DT的桶从10个空间扩容到32个

2024-4-8 240408-121000001
==================
1. 修改hp22mm.so，
    1. 在_print_thread函数中，增加定期读取supplay的status
       ids_get_supply_status(IDS_INSTANCE, sIdsIdx, &supply_status);
    2. 增肌两个接口函数Java_com_GetConsumedVol(JNIEnv *env, jclass arg) 和 Java_com_GetUsableVol(JNIEnv *env, jclass arg) {
       用来读取IDS的墨水总量和墨水消费量
2. 增加hp22mm的锁值显示，需要验证是否正确（在Hp22mmSCManager类中，修改getLocalInkPercentage函数）

2024-4-7 240407-120900001
==================
1. 如果是22mm的打印头，则根据参数2的值，给img设定打印方向(setMirror)
2. 对于2024-3-25修改的先下发数据后开始打印的修改，重新开始打印的时候，由于不再清理数据区，因此最好在停止打印的时候清理一下(uninit函数)，否则清洗可能会出乱码

2024-4-5 240405-120800001
==================
2024-3-25的240325-120100001版本修改太片面，导致新的apk在旧版的img上面，会出现第一个任务不打印的问题（因为先下发数据，但是旧版的img会忽略掉启动打印前下发的数据），
修改为根据img中的驱动的版本，旧的版本还是先启动打印，后下发数据，目的是保持兼容性。新的驱动则执行先下发数据，后启动打印

2024-4-3 240403-120700001
==================
修改22mm编辑页面高度管理。涉及MessageObject和PrinterNozzle类中的一些内容。

2024-4-3 240403-120600001
==================
增加一个新参数 22MM喷嘴选择

2024-4-3 240403-120500001
==================
加压超时从1分钟改为2分钟

2024-4-3 240403-120400001
==================
开机初始化如果失败，则每隔3秒重新尝试，直到成功为止，在此期间，无法点按打印按键。
点按按打印按键后，如果开始打印失败，则尝试重新初始化，成功则继续打印，失败则报错退出打印尝试。

2024-4-2 240402-120300001
==================
修改TestMain和TestGpioPinsNew类中的各显示字段，中英文如string，取消硬码
修改PlatformInfo类中计算FPGA版本号的方法，将HP22MM类型的版本号与4FIFO一样的方法计算

2024-3-29 240329-120200001
==================
追加一个限制打印次数的参数，该参数在数据源为扫描2时起作用。当数值=0时，不限制打印次数，数值>0时，对于新的扫描数据限制打印次数不超过该值。如果打印次数超限，则不下发打印数据，如果打印次数不足限制值时接收到新数据，则使用新的数据，并且更新为新的次数限制。
开始打印时，清空之前打印的剩余次数；并且首次不下发数据，直到接收到扫描2的数据后才开始打印。

2024-3-25 240325-120100001
==================
将DataTransferThread的PrintTask中先开始打印后下发数据的操作，修改为先下发数据，后开始打印。因为如果先开始打印，有可能在apk的打印数据还没有下发到驱动的时候，FPGA就触发了，这样可能空转。现在就发生了4FIFO的时候，第一张不打印的问题。
为此修改的地方为：
1. PrintTask中开始打印的FpgaGpioOperation.init从run函数的开始，移到下发数据以后，并且增加在开始下发数据前清空FIFO的调用
2. 在FpgaGpioOperation类中，将设置img的FIFO的功能从init函数移到updateSetting函数的最后
3. 在image中，取消startPrint函数中清空FIFO的功能
4. 在image中，接收打印数据的地方，取消接收数据时判断是否为打印状态的判断，因为apk会在开始打印前下发数据
5. 在image中，取消设置FIFO大小的时候对是否为打印状态的判断，因为打印中修改也没有问题

2024-3-25 240325-120000001
==================
取消hp22mm库当中使用spidev访问fpga的功能，转移到使用img当中的spi驱动

2024-3-23 240323-119900001
==================
240322-119800001版本修改2中的公式，对于C3的值理解有误，因此，恢复到原来的计算公式
	6 * C3 / 150 * C4 + C11 * C3 / 150
	6 * C3 / 150 * C4 + C12 * C3 / 150
	6 * C3 / 150 * C4 + C19 * C3 / 150
	6 * C3 / 150 * C4 + C20 * C3 / 150

2024-3-22 240322-119800001
==================
1. 修改HP22MM的一部分功能（还没有彻底完成）
2. 修改4FIFO时S15，S21，S22，S23参数的计算公式，修改为：
    (C11 + C4 * 6) * (C3 + 1)
    (C12 + C4 * 6) * (C3 + 1)
    (C19 + C4 * 6) * (C3 + 1)
    (C20 + C4 * 6) * (C3 + 1)

2024-3-17 240317-119700001
==================
取消240313-119000001版，及240317-119600001版对Printer.apk升级的修改，恢复到原来的直接升级U盘下的Printer.apk的原样

2024-3-17 240317-119600001
==================
240313-119100001版本修改升级文件为printer_xxxx.apk之后，这个文件不能被PowerManager的升级程序识别，导致无法升级，因此修改为
(1) 当根据printer_xxxx.apk与现apk进行判别，如果满足升级条件，则在实施升级前，将printer_xxxx.apk改名为Printer.apk（这个文件名是内部可识别升级文件名），并且生成一个长度为0的printer_xxxx.apk
(2) 待升级完成后，重启时，判断如果存在一个长度为0的printer_xxxx.apk，则将Printer.apk改名为printer_xxxx.apk，即恢复原文件名

2024-3-16 240316-119500001
==================
修改R15和R16参数的计算公式

2024-3-15 240315-119400001
==================
修改240314-119300001的bug

2024-3-14 240314-119300001
==================
修改240314-119200001的bug

2024-3-14 240314-119200001
==================
临时添加自动生成和下发hp22mm打印任务的版本

2024-3-13 240313-119100001
==================
240313-119000001版本中的3.1条，apk的名字修改为printer_xxxx.apk

2024-3-13 240313-119000001
==================
1. 取消hp22mm测试页面中的写FPGA Flash的功能（临时放置在这里的），改为从测试页面的M9测试页面中启动
2. M9测试页面中，添加一个单独写FPGA Flash的按键功能
3. 修改升级逻辑
   3.1 升级Printer.apk
     由原来的从U盘的根目录升级改为从U盘的根目录中升级以
     Print_xxxx.apk
     为文件名的文件升级。xxxx为任意长度唯一内容的字符
   3.2 升级FPGA固件
     在U盘的根目录下，生成一个FWupdate目录。
     在该目录中放置需要升级的FPGA固件文件，文件名为
     FW_xxxx.bin
     其中，xxxx为任意长度任意内容的字符。
     同时，在相同目录下放置伴随的MD5校验文件，文件名为
     FW_xxxx.txt
     文件名与预升级的bin文件相同，后缀为txt。该txt文件的内容为bin文件的MD5值。
     (生成MD5值可使用：https://www.nuomiphp.com/filemd5.html)
   3.3 升级KO驱动文件
     在U盘的根目录下，生成一个KOupdate目录。
     在该目录中放置需要升级的KO文件，文件名为
     FPGA的ko: SPI_xxxxx.ko
     GPIO的ko: GPIO_xxxxx.ko
     触屏的ko: LCD_xxxxx.ko
     RTC的ko: RTC_xxxxx.ko
     其中，xxxx为任意长度任意内容的字符。
     同时，在相同目录下放置伴随的MD5校验文件，文件名为
     FPGA的ko: SPI_xxxxx.txt
     GPIO的ko: GPIO_xxxxx.txt
     触屏的ko: LCD_xxxxx.txt
     RTC的ko: RTC_xxxxx.txt
     文件名与预升级的ko文件相同，后缀为txt。该txt文件的内容为ko文件的MD5值。

2024-3-11 240311-118900001
==================
修改240311-118800001版本bug

2024-3-11 240311-118800001
==================
修改M9测试页面布局和测试内容

2024-3-8 240308-118700001
==================
修改几个hp22mm驱动的下发参数

2024-3-7 240307-118600001
==================
新测试页面（新定名M9测试）功能梳理，确认第一个输出版本

2024-2-28 240228-118500001
==================
重新整理新的测试页面

2024-2-28 240228-118400001
==================
DataTransferThread类中添加了一行。原因是
txt文件有个不可见的文件头，UTF-8的文件头是EF BB BF，在从文件读入的第一行中，这个头会存在，并且以0xfeff的值存在，这个需要跳过，否则会导致GS1DM/QR生成失败。在这里排除是权宜之计，应该在QRReader里面排除，比较繁琐

2024-2-28 240228-118300001
==================
恢复2022-4-8修改的取消打印完成后停止打印的功能，但是延时1s停止

2024-2-28 240228-118200001
==================
修改数据源为DATA_SOURCE_GS1_BRACE时，判断QR文件是否到最后一条时的处理，这里在mCallback.onFinished(CODE_BARFILE_END)的时候，溜掉了对数据源为DATA_SOURCE_GS1_BRACE的判断

2024-2-26 240226-118100001
==================
暂时追加新的测试功能（部分）

2024-2-23 240223-118000001
==================
取消正在修改的TestGpioPins，恢复原来的TestGpioPins类。正在修改的新的测试页面使用新的测试入口启动

2024-2-22 240222-117900001
==================
追加一个GS1网络协议。内容与DATA_SOURCE_GS1_BRACE一样，只是数据从LAN来，走650或者600命令

2024-2-22 240222-117800001
==================
修改240221-117700001版本BUG。（生成GS1DM的二维码时生成了GS1QR码）

2024-2-21 240221-117700001
==================
修改240220-117600001，将GS1-2的数据修改为从QR.txt获得，而不是从串口获得

2024-2-20 240220-117600001
==================
增加一个数据源协议“GS1-2”，动作是当选择该协议的时候，有串口接收到的数为以下格式：
【0104607017595534215iD&U( 93CV0u】，其中
    01, 21和93为GS1的AI，01为固定长度（14个字符），21为可变长度，以空格为结束符，93为自定义AI，可变长度
 	AI原本使用方括号或圆括号作为标识，但由于用户数据中包含方括号和圆括号，因此使用花括号作为标识
 	将AI用花括号标识标注后，传递给GS1库生成二维码
为此对Gs1.java类做了修改，AI的分隔符在该协议时使用花括号，其它场合使用方括号和圆括号

2024-2-3 240203-117500001
==================
在打印GS1DM或者GS1QR的时候，如果桶里面保存的内容为没有标签的内容，如：
www.test-print.com
则生成GS1DM或者GS1QR的操作会因为没有标签而失败，导致生成一个空的图片，这会导致下发到img的数据长度为0，从而频发出发empty时间，而出现频繁的发送网络回复onComplete。
解决办法是，当生成GS1DM或者GS1QR时，如果开始字符不为"["或者"("，则添加一个"[21]"，既避免发生前述问题又避免用户已经添加标签而重复添加

2024-2-3 240203-117400001
==================
修改240203-117300001版本bug

2024-2-3 240203-117300001
==================
当使用SmartCard的时候，墨袋对应的是墨盒(1个或者2个)后面的头来显示在主页面，但是在计算这个对应头的阈值的时候，因为这个头实际上是没有真实头的，所以没有打印数据，点数为0，因此阈值会成为一个固定数65536*8
这会导致两个问题：(1) 开始打印时显示的墨袋(B)的初始剩余次数为一个固定值524288(65536*8)，(2) 打印过程当中减记打印次数时墨袋的次数不被减记。对此问题修改为：
    (1) 对应于墨袋的阈值按下列公式结算： threshold[B] = threshold[P1] * threshold[P2] / (threshold[P1] + threshold[P2])
    (2) 在countDown函数中，减记实际头的次数时也同时减记墨袋的剩余次数

2024-2-1 240201-117200001
==================
1. 在FileUtils类的copyDirectory函数中增加对/sdcard/system/F1.txt和/sdcard/system/F2.txt的屏蔽，这两个文件不做复制，避免被导入或者导出。目的是为了解决在最初的设计当中由于考虑步骤，错将F1和F2放在了/sdcard/system目录中，
   这个目录时可以被导出的，被导出的目录再次导入时，会将导出时的F1和F2导入，但是这个F1和F2记录的版本号不见得与当前的apk的版本号是一致的，导致apk无法启动的问题。
2. 在import_dialog.xml中，导入导出按键的字号修改为28sp，原来未36sp，会导致3.5寸小屏显示缺失

2024-1-31 240131-117100001
==================
1. 放开hp22mm库中的startPrint读取正式打印文件的部分代码，用来实现真正的打印
2. 整理代码，删除已经不使用的写PFGA的Flash的部分代码

2024-1-30 240130-117000001
==================
修改240130-116900001的bug

2024-1-30 240130-116900001
==================
取消240117-116500001 - 240123-116800001增加的临时测试功能
增加一个HP22MM的测试项目SPITest

2024-1-23 240123-116800001
==================
【临时】在116700001版本的基础上，增加开阀后初始化的操作，主要目的是创造一个在快速打印的过程当中，让SmartCard的访问负担加重，从而看出问题
恢复(240122-116600001取消的)去除打印缓冲区后部空白的功能

2024-1-23 240123-116700001
==================
【临时】跳过libsmartcard.so中downLocal函数对ILG的修改，并且修改打印500次开阀加墨。主要目的是测试国外出现打印10000次左右会出现死机的问题。（回头立即恢复）

2024-1-22 240122-116600001
==================
【临时】暂时取消删除打印缓冲区后部空白内容

2024-1-17 240117-116500001
==================
1. 修改导入导出对话窗，变成两行按键形式
2. 【临时】在测试页面临时增加两个蓝牙模块的测试功能，一个是先设PI9为高，另一个是先设PI9为低

2024-1-15 240115-116400001
==================
恢复正在修改中途的导入导出对话窗

2024-1-15 240115-116300001
==================
修改DynmacitText中设置位数的函数，如果新的位数小于等于0则直接返回，因为这会导致程序崩溃

2024-1-14 240114-116200001
==================
1. 优化扫描协议5的打印逻辑
2. 优化ko升级的验证逻辑

2024-1-13 240113-116100001
==================
修改扫描协议5的打印行为，只有收到扫描数据时才下发数据，否则不下发

2024-1-12 240112-116000001
==================
修改115800001和115900001的bug

2024-1-12 240112-115900001
==================
231230-115300001版本增加的超文本支持动态文本的功能，从在动态条码中实现改为在静态条码中实现，因此在生成打印缓冲区的时候，判断是否需要重画，只有需要重画的时候，静态文本也会因为还有可变的超文本内容而重画

2024-1-12 240112-115800001
==================
增加一个扫描协议5，要点：
(1) 不做第二位和最后一位的一致性检查；
(2) 扫描内容按网络协议650的规范，DT0-DT9,BC的格式，分别保存到桶和条码桶中

2024-1-9 240109-115700001
==================
修改DataTransferThread类中的countDown函数，目的是为了对应阈值小于1的情形，他的意义是一次打印需要消耗几次的锁值。如阈值为0.23，则打印一次需要减锁4.3次。

2024-1-8 240108-115600001
==================
修改DataTransferThread类中Threshold的计算方法。计算时考虑双列的设置，如果设置了双列，因为同样内容要被打印两次，所以要消耗墨水量也要加倍(对应于threshold减少)

2024-1-6 240106-115500001
==================
1. 更新5x5字体
2. 在control_frame.xml中追加一个ctrl_btn_up1的dummy控件，否则使用非定制扫码枪扫描的时候，系统内部（推测为将扫描数据转化为键盘事件的部分）会自动触发onClick事件而打开切换信息的提示窗。

2024-1-3 240103-115400001
==================
1. 追加一个通过U盘升级img的驱动的功能。
2. 增加要给获取img中驱动版本号并且显示的功能。
3. 同时对img做了相应的修改

2023-12-30 231230-115300001
==================
1. 在HyperTextObject类中，追加对DT的支持功能。
   DT的格式为 @#n#m#。其中@#作为DT的识别标签，n代表DT的索引，m代表DT的位数，第二个#为索引和位数的分隔符，第三个为DT的结束符
   4.1 修改HyperTextObject类parseContent函数，追加对DT的识别
   4.2 在getExpandedContent中，增加判断，如果是DT则返回桶里的内容，否则如果直接返回getContent，将返回缺省值，位数个的#
   4.3 增加setDTCntByIndex函数，对应于网络协议650，接收到的10个DT字符串顺序为对应的桶的顺序
   4.4 增加setDTCntByOrder函数，对应于网络协议600，接收到的10个DT字符串顺序为对应的DT变量的顺序
2. 在DataTask类中的refreshVariable函数中，增加HyperTextObject对于DT的支持
3. 在DataTransferThread类中，对应于600协议的setRemoteTextSeparated函数和对应于650协议的setRemote1TextSeparated函数中，追加对于DT的支持
4. 在HyperTextObject类的parseContent函数中，取消对TAG仅可出现一次的限制
5. 整理CRC16_X25和CRC16_MODBUS算法的代码
6. 追加一个CypherUtils类，用来计算文件或者流的MD5值
7. 将原来PrinterApplication类中的升级ko和so的代码独立出来为一个类（LibUpgrade.java）
8. 修改BarcodeScanParser类的扫描算法，原来的扫描算法会在汉字和%出现复杂组合时出现无法正确识别的问题
9. 替换12字体

2023-12-29 231229-115200001
==================
实现ko的通过apk升级功能。具体实现方法是：
1. 在apk的升级部分，将ko复制到/data/camera目录中，并且修改权限为644，然后自动重启
2. 在img的init.rc中，追加一个从/data/camera目录中将ko复制到/system/vendor/modules目录中的功能，该功能在重启机器时被执行
3. 增加asset中的新文件和img中的旧文件的MD5比较功能，只有有变化（解释为有更新）时才会操作1和2

2023-12-21 231221-115100001
==================
修改禁止大字机功能的标识未甄别是否为大字机的bug

2023-12-20 231220-31150 -> 231220-115000001
==================
（略）。

2023-12-19 231219-31149
==================
修改N_RFIDModule_M104BPCS_KX1207中密钥的算法

2023-12-18 231218-31148
==================
1. 修改N_RFIDModule_M104BPCS_KX1207的writePage和readPage，支持V0302版的带密钥读写接口
2. 修改读写失败后的逻辑，不在使用231202-31138版中的重新初始化后再次尝试读写，因为在N_RFIDManager中有无限循环在执行，因此只需初始化（writePage在新版中不需要验证密钥）
3. 增加一个写入P57的操作，虽然写入的是密钥的0xAA异或值，但值不重要，主要验证使用密钥写操作是否成功。如果成功，则说明卡是写入了正确的密钥，如果失败，则判定密钥有误，不允许继续执行

2023-12-18 231218-31147
==================
Params-29 Min limit to 20 from 200

2023-12-15 231215-31146
==================
修改NativeGraphicJni的bug，该bug导致内存泄露

2023-12-15 231215-31144, 231215-31144
==================
增加串口12接收数据后显示接受内容，与其他串口协议保持一致

2023-12-14 231214-31143
==================
在ControlTabActivity类的refreshInk函数中，对于当快捷模式从其它模式转换回USER_MODE_NONE时，需要重启，如果不重启这里就会发生mSubStepTV为空的问题，从而导致死机。
增加了是否为空的判断
			if(null != mSubStepTV) {

2023-12-13 231213-31142
==================
几处修改：
1. 支持QR.txt简洁格式（每行中没有序号，也没有DT0-9。直接是GS1条码的内容）(2023-12-12)。DataTransferThread.java
   即不是这种格式
   1,D10,D11,D2,D3,D4,D5,D6,D7,D8,D9,[01]05607017595534[21]ABCDEF ABCDEF[10]231120
   而是这种格式
   [01]05607017595534[21]ABCDEF ABCDEF[10]231120
2. 修改动态二维码录入方法。ObjectInfoDialog.java
   2.1 动态二维码的内容输入框设为不可编辑，并且内容为空
   2.2 当确定编辑内容提交时，GS1QR，GS1DM及GS1128的内容设为该格式名，并使用该内容生成示意二维码（条码），该内容在运行时将被远程数据取代，重新生成
3. 增加限制大字机打印功能。Configs.java和ControlTabActivity.java
   在Configs.java中追加PROHIBIT_BIG_DOTS_FUNCTION变量，当其为TRUE时，禁止大字机的打印功能。显示“print thread creation failed...”提示
4. 增加串口协议12。SystemConfigFile.java, SerialHandler.java, SerialProtocol12, DataTransferThread.java，及各语言版本arrays.xml
   报文 [FE 0F 4A 44 41 7C 76 31 3D 20 31 30 33 31 7C 0D 0A]，取第10字节开始的4个字节[31 30 33 31]赋值给DT0

2023-12-5 231205-31140
==================
4 fifo 版本，清洗要特别处理，发的参数，4个偏移，都要发0. 别的和HP一样就行

2023-12-4 231204-31139
==================
1. (2023-12-3)修改1207卡的锁值刻度为固定的1000及相应的修改。
   1.1 具体修改逻辑看N_RFIDModule_M104BPCS_KX1207类中的补充说明
   1.2 增加一个getMaxRatio接口用来传递阈值的调整倍率
2. 取消220524-30861版本中增加的apk升级方法（改用采用新的F1及F2的新的升级方法）
（取消的代码已经从源代码中删除，主要涉及SystemConfigFile类，ControlTabActivity类和PackageInstaller类中的相应内容）

2023-12-2 231202-31138
==================
由于切换卡时切出的卡会断电，因此，再次被切入的时候，即使在写操作之前进行verifyKey，该验证函数本身就会失败，因此取消231202-31137的两个修改。改为一下修改。
1. 在N_RFIDModule_M104BPCS_KX1207类的writePage函数中，如果写失败，则重新初始化模块，然后进行密钥验证，如果成功，则再次尝试写入，并且将结果返回（可能成功，如电源重新切入；也可能失败，确实出现模块问题，卡拔出等问题）
2. 在N_RFIDModule_M104BPCS_KX1207类的readPage函数中，如果读失败，则重新初始化模块，如果成功，则再次尝试读，并且将结果返回（可能成功，如电源重新切入；也可能失败，确实出现模块问题，卡拔出等问题）
3. 取消N_RFIDModule中的mInitialized变量，该变量由于是在读写时如果失败，则设置为false，提示后续处理重新初始化模块。但是由于1和2的处理，这个表示已经不需要
4. 取消N_RFIDModule_M104BPCS_KX1207类的mKeyVerified变量，该变量的作用是初始化时对密钥进行验证后，以后不需要验证。但是由于1和2的修改，这个变量已经不需要

2023-12-2 231202-31137
==================
修改1207卡的问题。打印过程中，写卡失败。经确认为写卡之前需要验证（以前只要初始化时验证一次即可，现在似乎验证有效只维持一段很短的时间）。具体修改内容：
1. 在N_RFIDModule_M104BPCS_KX1207类的writePage函数中，实施写卡操作之前执行一下卡的验证
2. 在N_RFIDModule_M104BPCS_KX1207类的verifyKey函数中，取消如果卡已验证则跳过的部分，否则写卡前的验证会被跳过，而不起作用

2023-12-1 231201-31136
==================
2023-9-20 230920-31098追加的步长细分数值显示窗，原来只是针对标准的用户模式，如果在其他模式调用确实会发生死机（因为在control2_frame，control3_frame及control4_frame中没有该控件的声明），因此，需要在使用该控件时，限定为标准用户模式（USER_MODE_NONE）

2023-12-1 231201-31135
==================
1. 修改升级盘验证算法，由原来的只验证第79文件，改为验证第79， 105，211，487，731文件的文件名。
2. 验证文件中填充了dummy数据

2023-11-29 231129-31134
==================
1. 修改CalendarDialog中升级apk的部分，支持最新的防交叉升级功能
2. 将屏保开始时间从1分钟调整为3分钟

2023-11-28 231128-31133
==================
解决静止1分钟之后屏幕变暗，在对话窗中点击画面也不变亮的问题。
1. 增加一个RelightableDialog类，继承Dialog类，该类的主要功能是接收点击事件，并且点亮屏幕，同时1分钟无操作的情况下，再次变暗
2. 修改所有Dialog类的派生类，改为继承RelightableDialog类。这样就可以使得所有这些类都可以被点击事件点亮

放开新的版本升级机制的全功能。涉及：
WelcomeActivity类的case LAUNCH_MAINACTIVITY
和PackageInstaller.java的silentUpgrade3函数。checkUSBAuthentication3函数暂时使用原checkUSBAuthentication函数的机制（仅检测第79个文件的文件名）

2023-11-27 231127-31132
==================
优化生成GS1QR及GS1DM的流程，提高处理速度

2023-11-23 231123-31131
==================
追加GS1-128，及对BarcodeObject类的draw函数优化

2023-11-22 231122-31130
==================
修改231121-31129中的几处Bug

2023-11-21 231121-31129
==================
追加GS1的QR和DM

2023-11-18 231118-31128
==================
将230921-31099版本中的计算公式，由
6 * C3 / 150 * C4 + C11[C12, C19, C20] * C3 / 150
改为
C11[C12, C19, C20] * C3 / 150

2023-11-15 231115-31127
==================
在InkManagerFactory类和InkSchedulerFactory中，取消2023-5-17及2023-10-18判断1207卡模块的方法，改为自动判断。当判定模块为DPCS模块时，启用原RfidManager类，1207模块时，启用N_RfidManager。
因此，N_RFIDDevice中仍然固定模块种类为1207（待所有Rfid的管理流程都并入到N_RfidManager体系之后，在恢复为在这里做判断，而不在Factory类中判断）
img同时取消为1207特定的img种类。

2023-11-12 231112-31126
==================
修改231112-31125版本在getFPGAVersion和getImgUniqueCode之间的循环参照，修改了getFPGAVersion函数的形参，以避免在getFPGAVersion中调用getImgUniqueCode。

2023-11-12 231112-31125
==================
在Platform类的getFPGAVersion函数中，暂时变更4FIFO版本号的取位规则

2023-11-3 231103-31124
==================
修改俄文限制提示文字。取消“Permission Denied: ”，保留”Russian character not allowed“

2023-11-2 231102-31123
==================
追加两个网络命令，同步器(encppr)和旋转(slant)

2023-10-31 231031-31122
==================
给俄语控制功能增加一个开关，设置在Configs类中。
	public static final boolean RUSSIAN_CONTROL = false;
为true时，控制含有俄文字符信息的打印，为false时，允许含有俄文字符信息的打印

2023-10-30 231030-31121
==================
增加禁止俄文字符的机制。
1. 在StringUtil类中增加一个判断是否包含俄文字符的函数containsRussian
2. 增加一个异常类RussianCharException
3. 在TLKFileParser类中，增加一个根据读到的内容判断是否为俄文字符的功能，如果包含俄文字符，则抛出RussianCharException异常

2023-10-28 231028-31120
==================
修改231028-31119版本，打印方向(Direction)和倒置(Inverse)改为上电期间内保留设置内容

2023-10-28 231028-31119
==================
增加打印方向(Direction)和倒置(Inverse)
    =0: 无操作； =1: 生成时，设备内设置参数相反
    仅限大字机，=0: 无操作； =1: (1-16)及(17-32)单独反转； =2 (1-32)整体反转

2023-10-26 231026-31118
==================
追加IN-8：0x80：低有效，常态高。IN-8=0时，喷码机在等待打印状态下清洗一次

2023-10-26 231026-31117
==================
追加一个参数FEEDBACK(网络回复)，当=0时，按当前逻辑回复PC端，当=1时，在打印完成后，回复0002到PC端

2023-10-25 231025-31116
==================
1. 修改PrintTask在empty事件以后，回送onPrinted的判断条件，如下：
由
            if(!mUsingFIFO) {
改为
			if(!mUsingFIFO &&
				(SystemConfigFile.getInstance().getParam(SystemConfigFile.INDEX_DATA_SOURCE) != SystemConfigFile.DATA_SOURCE_SCANER3 ||
				(SystemConfigFile.getInstance().getParam(SystemConfigFile.INDEX_DATA_SOURCE) == SystemConfigFile.DATA_SOURCE_SCANER3 && dataSent))) {
主要原因是，当数据源是扫描协议3的时候，如果没有扫描数据下发，会频繁出现empty事件，这样就会频繁会送0000。本修改主要是为了避免该情况。
2. 修改参数设置页面FIFO编辑框有时不能选择的问题。主要是设置3.5寸亮度的地方设置为了disable，在FIFO重用的时候继承了该属性，因此需要设回去。
    添加改行
    if(!mHolder.mValueREt.isEnabled()) mHolder.mValueREt.setEnabled(true);

2023-10-25 231025-31115
==================
为了网络回送报文逻辑恢复到从前的状态。231023-31113版本修改1中放开了是否为FIFO的判断，因此需要在发送onPrinted的地方加上，否则逻辑就回复不到原来的状态。

2023-10-25 231025-31114
==================
网络回送报文逻辑恢复到从前的状态。具体如下：
1. 取消231018-31109版本修改2。恢复为即使在网络快速打印和扫描3时，初始没有下发数据，也会回送onComplete(0001)
2. 取消231021-31110版本修改4。该修改内容将转移到未来增加的完成打印恢复(0002)中

2023-10-23 231023-31113
==================
1. 在PrinterTask类的run中，取消获取实际打印数量的部分仅适用于FIFO的情况（因为FpgaGpioOperation.getPrintedCount()最初的目的是在FIFO的时候，避免CounterObject记忆已下发值而非实际打印值），因为主页面显示的打印数量已经修改为实际打印数量。
2. 在InkManagerFactory类和InkSchedulerFactory类中，追加OS07（7寸SPI采用1207RFID卡）和OG07（7寸GPIO采用1207RFID卡）的判断

2023-10-21 231021-31112
==================
修改打印后，打印计数不变化的问题。原因是当启用FIFO的时候，FIFO中可以有多个任务等待打印，这些任务在被打印的过程当中，实际上是不需要有新任务下发的，因此也就不会调用更新打印计数显示。
在DataTransferThread类中的PrinterTask子类的run函数中，在获取打印计数后
		lastPrintedCount = FpgaGpioOperation.getPrintedCount();
追加一个更新计数显示的调用
		mInkListener.onCountChanged();

2023-10-21 231021-31111
==================
修改N_RFIDModule_M104BPCS_KX1207类中，readMaxInkLevel函数中以前用来调试的
    max = 1000;
的语句，该语句导致墨水最大值被固定在了1000

2023-10-21 231021-31110
==================
1. DataTransferThread类中追加变量：
	private int mDownWrittenCount;  // 用来保存已经下发到img的任务的数量。每次下发新数据加1
	private int mLastPrintedCount;  // 用来保存上次查询时已打印任务数量。其目的是方便这次查询已打印数量时，获取两次查询时间段内新近完成的打印数量
2. DataTransferThread类中追加两个函数：
	public int getRecentPrintedCount()  // 用来查询从上次查询到这次查询时间段内，新近完成的打印任务数量
	public int getRemainCount()         // 用来查询img中驻留的未打印任务数量
3. ControlTabActivity类中，打印计数其mCounter不再每次下发加1，而是根据实际打印完成的任务数增加，此处修改在onCountChanged函数中
4. 在打印完成后的网络反馈报文中，增加已打印任务数量和img驻留未打印任务数量的信息。但是由于img当中，数据从FIFO转移到下发缓存后，FIFO即产生空位，而此时apk可能就会下发新的数据，而此时下发缓存中的任务还没有打印完成。因此，此处
   获得的驻留任务数量可能等于FIFO的空间数+1。
5. 修改DataTransferThread中网络快速打印数据下发的逻辑。删除mFirstForLanFast变量。以前的逻辑会发生下发打印数据后，还没有触发打印之前，如果再次通过网络发送打印数据，会再次下发的问题。经过仔细分析，mFirstForLanFast本来可以不用，
   用mDataUpdatedForFastLan适当的判断就可以实现网络快速打印的下发逻辑，并且能够避免引入mFirstForLanFast，而操作不当而导致的上述问题。使用mFirstForLanFast的源代码已经删除，如果需要参照，可以从git的历史数据中查找

2023-10-18 231018-31109
==================
1. 取消230517-31042的修改，改为根据img的版本号来启动Rfid的实现路径。NSM2时使用1207，其他的启用原来的逻辑
2. DataTransferThread类中，PrinterTask类中，第一次下发数据后发送onComplete，避免网络快速打印时，没有下发数据也会发送一次网络回复1.

2023-10-18 231018-31108
==================
修改231016-31106版本bug
1. 由于没有修改params.xml参数57的最大值限制，导致P7无法保存
2. 警示灯改为点亮30秒

2023-10-17 231017-31107
==================
修改231016-31106版本中的修改bug。
RTCDevice类中的jni函数，虽然没有在使用，但是必须保留这几行声明，否则Hardware_jni里的相应接口可能是找不到调用者，导致运行时出现空指针异常。如果删除，必须双侧都要删除。
	public static native int open(String dev);
	public static native int close(int fd);
	public static native void syncSystemTimeToRTC(int fd);	//write
	public static native void syncSystemTimeFromRTC(int fd); //read
上述API。

2023-10-16 231016-31106
==================
追加一个输入设置参数的取值，定义为P-7。其意义为：计数细分填入大于0的数值时，当细分次数达到预设次数时，PH7灯亮20秒

2023-10-13 231013-31105
==================
取消231012-31104的修改，改为：
增加一个AD参数，当AD=0时，按原有策略(根据img的类型显示电池图标）；当AD=1时，无条件显示电池图标；当AD=2时，显示气压参数，具体方法待定

2023-10-12 231012-31104
==================
在Configs.java类中追加一个电池图标显示开关。
	public static final boolean BATTERY_ALWAYS_ON = false;
当其为true时，无条件显示电池图标；当期为false的时候，按着从前的逻辑，根据img的种类决定是否显示电池图标。

2023-10-3 231003-31103
==================
临时添加一个保存(Test001)1000次的强度试验，暂时放在这里，待以后再次确定

2023-9-28 230928-31102
==================
修改230921-31099版本修改1的bug，在判断条件前错加了！号，取反了。

2023-9-24 230924-31101
==================
在CalendarDialog类中，设置时间是，采用带秒值的api，秒值固定为0

2023-9-24 230924-31100
==================
在230905-31096版本的基础上，修改bug，尽量保证写出的log能够保存到USB盘的物理介质中。

2023-9-21 230921-31099
==================
1. 在Paramter类中，对应于img类型为4FIFO的img，不执行位移操作，但是将位移操作的参数传递给FPGA。具体公式为：
6 * C3 / 150 * C4 + C11[C12, C19, C20] * C3 / 150
2. 在Configs类的getMessageShift，对应于img类型为4FIFO的img，返回0，使得不执行位移操作

2023-9-20 230920-31098
==================
在ControlTabActivity中，如果点击步长数值显示框，则打开一个编辑步长细分数值的对话窗。

2023-9-20 230920-31097
==================
修改步长细分的几个功能：
1. 现使用APK在关机、断电、停止打印的情况下，再次启动打印时会按第一次开始，改为接上次值继续喷印
    例如 步级细分设置5    信息为两位计数器   打印00  00  00  00  00，5次00后自动进入01 ，当01打到第三次的时候我们进行断电、关机、停止中任意一种操作，当再次启动打印时，是从第一个01开始喷印的，需要改为断电、关机、停止任何操作后接上次值继续喷印，也就是打第四次01。
2. 当设置步级细分后 主界面的信息名称最右侧位置显示步级细分打印次数。比如步级细分设置为10次，那喷印一次界面次数就显示1，依次类推。10次喷印完又从1开始显示。
3. 步长细分的当前值，保存到RTC设备（1338）的0x3c位置
4. 对于RTCDevice类的读写整数功能进行了函数化精炼。

2023-9-5 230905-31096
==================
在Import对话窗中追加一个向U盘输出Log的按钮，目的是在发生错误的时候，不用链接PC机就可以获得Log。

2023-8-23 230823-31095
==================
修改BarcodeObject类中的getPrintBitmap函数，该函数仅被生成打印缓冲区的部分调用，此时需要使用桶里的内容，而非原有内容，否则会导致PCFIFO设置的内容不能被反映到打印内容中。

2023-8-22 230822-31094
==================
1. 更换7号字体
2. 修改SystemConfigFile类中获取主要头的函数getMainHeads中，1带多时的返回值。原来返回0，会导致1带多以外的头也会被赋值头0的点数。虽然没有实际的影响，但是看着不正确
3. 修改DataTask类中的calDots函数。n带m是，由于生成打印缓冲区数据的时候已经根据扩大倍数对打印缓冲区进行了扩大，因此计算出来的头0的点数是扩大后的点数，这样会导致1带多的墨点计数被扩大。
4. 修改SerialPort类的openXXX函数，由固定波特率9600，需改为有参数指定。修改的目的是兼顾蓝牙芯片的通讯（115200），原有的串口通讯波特率仍为9600，由上级调用时指定。

2023-8-20 230820-31093
==================
修改230819-31092版本的BUG

2023-8-19 230819-31092
==================
修改230818-31091版本的BUG

2023-8-18 230818-31091
==================
把开机时的Data Loading画面移到WelcomeActivity。这个Activity因为没有开始任何的初始化，因此，如果死机是由于数据引起的是可以避免的。具体做法如下：
1. 在开机时，当看到Data Loading...画面的时候，长按屏幕中心部分，显示对话窗，可以选择
    (1) 备份数据后清空数据：将MSG，picture及system目录下的数据备份到U盘后，清空本地数据，然后启动apk
    (2) 直接清空数据：直接清空本地数据，启动apk
    (3) 继续启动：直接启动apk
    如果在15秒内没有任何操作，则直接启动apk。
2. 启动该对话窗需要长按屏幕中心位置，偏离中心区域会没有反应。
3. 需要开机后显示Data Loading后再长按屏幕中心，如果在没有显示Data Loading前就一直按下屏幕中心，不会有反应
4. 开机后显示Data Loading后，如果没有长按屏幕中心，5秒后会自动启动apk

2023-8-14 230814-31090
==================
重新编译230814-31089版本。可能是由于编译器的原因，管理管脚协议的Timer间隔时间在RFID报错的情况下不正常。

2023-8-14 230814-31089
==================
修改230814-31088版本的BUG，恢复关闭错误提示灯的操作，可能会导致RFID报错的提示灯被关闭。放在墨位或溶剂状态变高的时候关闭可以避免这个问题。

2023-8-14 230814-31088
==================
1. 修改230812-31086的BUG，该BUG在显示墨位低/溶剂低提示窗时，由于是在线程中调用UI，造成崩溃
2. 追加PH7，错误提示灯的显示（发生错误时）和关闭（错误恢复时）

2023-8-14 230814-31087
==================
网络查询命令(400/Inquery)的返回值中，使用喷头7和喷头8的位置返回墨位及溶剂状态。低为T（仅协议6时有效，其他协议时为常F），高为F。

2023-8-12 230812-31086
==================
修改了前一个版本的BUG

2023-8-12 230812-31085
==================
1. 理顺P1-P5的逻辑。
   P1：禁止GPIO
   P2：控制打印
   P3：控制方向
   P4：综合
   P5：清零
   之前的修改P4与P5有些混淆，现在明确了，P4为综合功能，P5为清零
2. 增加P6协议

2023-8-11 230811-31084
==================
修改230811-31083版本中purge32.bin的文件名写错了的错误。

2023-8-11 230811-31083
==================
1. 短清洗的时候，如果喷头为32SN/DN或者是48点，则使用新的bin文件，purge32.bin。
2. 短清洗的时候，如果喷头为32SN/DN或者是48点，则S5下发统一为600，不在特殊处理（200/4）

2023-8-10 230810-31082
==================
DataTask类中的preparePurgeBuffer函数中，生成大字机的时候，生成为原来的2倍

2023-8-10 230810-31081
==================
对230802-31075版本，根据用户的要求《软件问题反馈0804(lv).doc》进行了修改。

2023-8-10 230810-31080
==================
1. 将ControlTabActivity类中的MESSAGE_RFID_ALARM报警改在线程中实现，以防止界面卡顿
2. 将230809-31079版本中实现Purge(200)下发的时候，如果参数未0，则S12下发0xFFFF。

2023-8-9 230809-31079
==================
取消230807-31077中，将1-12头的指定，换算成组号下发的操作，改为直接下发头号。也不再对bin文件进行预处理。

2023-8-8 230808-31078
==================
追加一个SelectPen网络命令，格式与Purge命令的格式相同。在content字段的后六位设置被选头的组，格式为六位二进制数，1代表选中，0代表未选中。其他值报错。

2023-8-7 230807-31077
==================
追加XL头12个头的清洗使能功能。为命令200和Purge在content字段增加参数1-12。代表要清洗的头

2023-8-4 230804-31076
==================
在ObjectInsertDialog当中，追加一个关闭按钮，作为不做任何插入而直接退出的手段。

2023-8-2 230802-31075
==================
对于230707-31056增加的用户界面，根据用户的要求(新用户界面目录下的《软件问题反馈0717v3.doc》)做了补充修改。主要内容位：
1. 显示内容的要求主要修改了control4_frame.xml中的布局。因为这个布局文件是给这个用户专用的，因此修改时受其他页面的牵制比较少。
   同时，在string.xml(仅英文，中文简繁体)中追加了一些字符串，主要是为这个用户专用
2. 修改修改MessageBrowserDialog中的排序规则为长度优先，相同长度后按ASCII排序（已在230727-31071版本修改），补充一下修改遗漏。
   遗漏点1：按向下箭头时的操作没有相应修改为长度优先
   遗漏点2：find函数中没有相应修改长度优先，导致查找不到
3. 取消MessageBrowserDialog对话窗中长按打开多选模式，以避免用户误操作倒置该模式被打开。

2023-7-31 230731-31074
==================
增加48点打印头

2023-7-28 230728-31073
==================
修改主画面中上下箭头更换信息时，恢复为按着长度优先原则排序。

2023-7-28 230728-31072
==================
修改MessageBrowserDialog中的sort函数，将2023-3-27取消的长度优先排序恢复回来。

2023-7-27 230727-31071
==================
修改hp22mm库内部取得错误信息的方法。在common.c里面启用char ERR_STRING[1024];变量

2023-7-27 230727-31070
==================
修改22mm测试库当中，startPrint的返回值，
修改前：0为成功，-1为失败
修改后：""为成功，有内容字符串为失败

2023-7-25 230725-31069
==================
1. 取消一些初始化时重复无用的log
2. 解决PC_FIFO为空时打印死机的问题。原因是onPrinted()函数中在空的数据中删除元素导致越界崩溃

2023-7-24 230724-31068
==================
停止打印时，清空PC_FIFO

2023-7-24 230724-31067
==================
1. 修改PCCommandHandler类，将提示显示窗修改为多次接收到报文时在同一个对话窗内覆盖显示，而不是当前的多个对话窗分别显示
2. 在报文提示信息上部增加时间显示，格式为[mm:ss]（分秒）。
3. 提示对话窗显示5秒后自动关闭

2023-7-24 230724-31066
==================
在PCCommandHandler类的handle函数中，当接收到网络的600或者650报文时，如果是PC_FIFO被启用的状态下，要在提示窗中显示收到的报文内容

2023-7-24 230724-31065
==================
1. 在SettingsTabActivity类的parseSystemCofig函数中，增加对PC_FIFO参数范围的检测（属于2023-3-12修改时的遗漏项目）
2. 修改当PC_FIFO为0时，死机问题。原因是在PC_FIFO类的onPrinted函数中，没有检测当前缓冲区的数量而执行删除元素操作，当数量为0时如果执行删除，则会发生越界异常

2023-7-21 230721-31064
==================
将2307020-31063版本中的修改2扩大到所有的R.style.Dialog_Fullscreen对话窗，并且对相应的对话窗做了布局调整，以适应修改后显示布局的变化

2023-7-20 230720-31063
==================
1. 修改测试页面群的实现方式，将原来通过多个PopupWindow来实现的方式改为只用一个PopupWindow，在上面叠加工作区的方式实现，这样可以避免画面抖动
2. 在MessageBrowserDialog中，取消
	super(context, R.style.Dialog_Fullscreen)
    因为如果指定Theme，则在显示对话窗的时候，会跟随系统的亮度立即调整，如果系统的亮度设置的比较低，则会立即变暗。修改为：
	super(context)
    不指定Theme，然后在onCreate函数中，执行
	getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
	WindowManager.LayoutParams lp = getWindow().getAttributes();
	lp.width = WindowManager.LayoutParams.MATCH_PARENT;
	lp.height = WindowManager.LayoutParams.MATCH_PARENT;
	getWindow().setAttributes(lp);
    来将对话窗调整为充满屏幕

2023-7-18 230718-31062
==================
修改PrinterNozzle类中的初始化函数，将NOZZLE_TYPE_32SN时的buffer8Enable设为false，避免倾斜处理。

2023-7-17 230717-31061
==================
1. 2023-7-13修改。在GpioTestPopWindow类中，HP22MM_WRITE_SPIFPGA的时候，取消对PI9的操作。
1. 2023-7-15修改。在FpgaGpioOperation类中，下发参数以后，如果是打印状态则恢复为OUTPUT状态，如果是非打印状态则恢复为CLEAN状态
2. 2023-7-17修改。在MainActivity类中，由原来的10秒后调节亮度，改为60秒后调节亮度
	mHander.sendEmptyMessageDelayed(ENTER_LOWLIGHT_MODE, 60 * 1000);
3. 2023-7-17修改。在MainActivity类的setScreeenBrightness函数中，如果是3.5寸屏
	info.startsWith("NNG3") || info.startsWith("ONG3") || info.startsWith("GZJ") || info.startsWith("NSM2")
    则，亮度固定为50%
4. 2023-7-17修改。在SettingsListAdapter类中，getView函数中，如果是在显示第44参数（亮度），则如果是3.5寸屏，则内容设置为50，不能编辑
5. 测试画面由原来的一个画面，从底部选择测试项目，改为3级画面。第一级画面为机型选择画面；第二级画面为测试项目选择画面；第三级画面为实际测试画面

2023-7-10 230710-31060
==================
无修改，仅为再push

2023-7-10 230710-31059
==================
修改FPGA写入FLASH的功能，增加一个FPGA属性：
FPGA_STATE_UPDATE_FLASH(6)

2023-7-7 230707-31058
==================
1. 修改2023-6-19 230619-31051当中，对于未插卡是报错和插卡后恢复的修改，增加的refreshInk函数中的valid变量。原来的修改没有考虑处于打印状态时print按钮失效的问题，增加该考虑
2. 新的用户界面的Import按钮修改为实现原界面的Tranfer按钮的功能

2023-7-7 230707-31057
==================
取消2023-2-23 230223-31017中对C63->S11的转换计算，恢复到原来的
C63/2
的计算公式。放置位置仍然为S11[7:3]

2023-7-7 230707-31056
==================
增加一个用户追加的页面。该页面是在原有ControlTabActivity的基础上进行修改的。具体修改内容如下：
1. 新生成一个control4_frame.xml文件，定义新的布局文件。为了保持与原有代码的兼容性，有一些未使用到的空间设成了不可见，但并且删除，因为删除了的话，ControlTabActivity将无法发现空间而报错退出
2. 在string.xml（多语言版本）中增加了一些新增加的字符串
3. 在Configs.java类中追加了下列定义。UI_TYPE用来记忆本次编译时所使用的UI种类。
    UI_STANDARD表示原来传统的UI，UI_CUSTOMIZED0表示本次增加的新的UI。
	public static final int UI_STANDARD = 0;
	public static final int UI_CUSTOMIZED0 = 1;
	public static int UI_TYPE = UI_CUSTOMIZED0;
    新追加的功能，都是在MainActivity.java或者ControlTabActivity.java类中，根据UI_TYPE进行追加的
4. MainActivity.java，ControlTabActivity.java及EditTabSmallActivity.java类中对应于新的UI以及用户对功能的要求做了相应的追加和修改
5. 本次修改时间跨度很大，在注释中囊括在对应于日期2023-6-25，2023-6-26，2023-6-27和2023-7-6的注释当中

2023-7-3 230703-31055
==================
2022-4-1 220401-30806版本中对DataTask类中生成动态文本时，在12.7xn没有做倍率调整的问题的修改，没有适用于条码，实际上条码也存在相同的问题。这次追加了对条码进行的修改。
即根据12.7xn头的n，做相应的倍率调整。

2023-6-21 230621-31054
==================
在DataTransferThread类中，临时注释掉当收到empty事件以后，重新生成打印缓冲区的操作，以便确认是否在快速打印的时候，生成打印缓冲区操作耗时导致数据跟不上

2023-6-19 230619-31053
==================
将230614-31050版本的输出格式改为：AxxxBxxxCxxxDxxx。
xxx为0时，相应项目无输出

2023-6-19 230619-31052
==================
假墨袋，忽略墨盒错误版本。

2023-6-19 230619-31051
==================
2023-6-18修改
修改com_smartcard.c中mutex的初始化和shutdown的处理，目的是使得该库启动后一直有效。
并且，修改SmartCardManager.java类中的一些地方，目的是当开机时没插卡（包括通讯不畅）或者打印中拔卡后，再次插入卡可以恢复。

2023-6-14 230614-31050
==================
追加一个SmartCard出错状态的显示功能。显示的位置是信息名称的下面，14sp大小的字体（小字）。格式是：
1111*2222*3333*4444
1111为初始化失败的次数
2222为初始化失败五次后再次重新初始化的次数
3333为写锁值出错的次数
4444为写锁值出错三次后启动重新初始化的次数
该功能仅在SmartCard版本时，处于打印状态下才被启动

2023-6-9 230609-31049
==================
在DataTransferThread类中的setContentsFromQRFile函数中，将取消掉的setContent函数全部恢复，否则DT或者Barcode的内容不能立即反应在变量当中。

2023-6-5 230605-31048
==================
修改LetterMonthObject类中的makeVarBin函数，其中将scaleW除2的操作，导致每个VBin的元素的宽度减半变形。

2023-5-31 230531-31047
==================
取消230529-31045中S6乘以2，恢复到原来的值：1500
当打印头为32SN或者32DN的时候，S5不在按着230529-31045的修改乘以3，而是除以4

2023-5-30 230530-31046
==================
修改DataTransferThread类中的以下两处，否则可能当时的修改不能及时反映到内容中，只有再次开始打印才会起作用。
// H.M.Wang 2023-5-30 放开这个注释，否则新的DT可能不能及时反映到当前的变量中
	baseObject.setContent(recvStrs[strIndex]);
// End of H.M.Wang 2023-5-30 放开这个注释，否则新的DT可能不能及时反映到当前的变量中
// H.M.Wang 2023-5-30 放开这个注释，否则新的BC可能不能及时反映到当前的变量中
	((BarcodeObject)baseObject).setContent(recvStrs[10]);
// End of H.M.Wang 2023-5-30 放开这个注释，否则新的BC可能不能及时反映到当前的变量中

2023-5-29 230529-31045
==================
S5 从200修改为600； S6从1500修改为3000

2023-5-24 230524-30003-22MM
==================
【22mm】专用测试版
1. 临时修改下发打印数据为固定数据（目的为确认动作，正式版本需要恢复）
2. 在22mm的测试栏里面，临时追加了PI4和PI5的操作，目的是确认M2是否能过够正确的操控PI4和PI5

2023-5-19 230519-31044
==================
取消2020-12-12对DataTask类当中，refreshVariables函数中，生成动态二维码部分的覆盖贴图修改，恢复到原来的或贴图。当初做的修改主要是PC保存的时候，动态二维码会保存一个假图，这里或生成的话，会出现叠加。现在似乎PC已经修改好了，反倒由于覆盖贴图，可能会消除掉原来地图的内容。

2023-5-18 230518-31043
==================
1. 将31042版本当中的判断标准，从101改为102。即，当>=102的时候启用新版N_RFIDManager和N_RfidScheduler（暂时仅支持1207卡），如果<=101，则启用原来的RFIDManager和RfidScheduler
2. 增加RFIDDevice和N_RFIDDevice类中对特征值的判断，但为Bagink的时候，如果Feature[6]不在[64,164)之间的时候，则改设备无效，禁止打印

2023-5-17 230517-31042
==================
修改RFID1207模块的启动模式。
根绝RFIDDevice.FEATURE_HIGE的值，如果<=100，则启用原来的RFIDManager和RfidScheduler，如果>=101则启用新版的N_RFIDManager和N_RfidScheduler。并且，在N_RFIDDevice当中，暂时取消自动判断模块的功能，直接强制启动1207模块的功能。待以后对新的功能中对于原有模块的支持经过产品级测试后，再放开。

2023-5-15 230515-31041
==================
屏幕180度旋转（左上转到右下）功能的追加，需要img的支持，img的修改内容为

【android42/device/softwinner/common/packages/TvdSettings/res/xml/accessibility_settings.xml】
@@ -32,11 +32,11 @@
             android:key="screen_magnification_preference_screen"
             android:title="@string/accessibility_screen_magnification_title"/>
 
-        <!--CheckBoxPreference 
+        <CheckBoxPreference 
                 android:key="rotate_screen"
                 android:title="@string/rotate_screen_tittle"
                 android:persistent="false"
-                /-->
+                />
         <CheckBoxPreference
                 android:key="toggle_large_text_preference"
                 android:title="@string/accessibility_toggle_large_text_preference_title"

【android42/device/softwinner/common/packages/TvdSettings/src/com/android/settings/AccessibilitySettings.java】
@@ -174,8 +174,8 @@ public class AccessibilitySettings extends SettingsPreferenceFragment implements
     private PreferenceCategory mServicesCategory;
     private PreferenceCategory mSystemsCategory;
     
-//    private final String ROTATE_SCREEN="rotate_screen";
-//    private CheckBoxPreference mRotateScreen;
+    private final String ROTATE_SCREEN="rotate_screen";
+    private CheckBoxPreference mRotateScreen;
     private CheckBoxPreference mToggleLargeTextPreference;
     private CheckBoxPreference mTogglePowerButtonEndsCallPreference;
     private CheckBoxPreference mToggleLockScreenRotationPreference;
@@ -193,12 +193,12 @@ public class AccessibilitySettings extends SettingsPreferenceFragment implements
         super.onCreate(icicle);
         addPreferencesFromResource(R.xml.accessibility_settings);
         initializeAllPreferences();
-//        mRotateScreen=(CheckBoxPreference)findPreference(ROTATE_SCREEN);
-//        int RotateScreen=Settings.System.getInt(this.getContentResolver(), "rotate_screen", 0);
-//        if(RotateScreen==1)
-//        	mRotateScreen.setChecked(true);
-//        else
-//        	mRotateScreen.setChecked(false);
+        mRotateScreen=(CheckBoxPreference)findPreference(ROTATE_SCREEN);
+        int RotateScreen=Settings.System.getInt(this.getContentResolver(), "rotate_screen", 0);
+        if(RotateScreen==1)
+        	mRotateScreen.setChecked(true);
+        else
+        	mRotateScreen.setChecked(false);
     }
 
     @Override
@@ -239,11 +239,11 @@ public class AccessibilitySettings extends SettingsPreferenceFragment implements
     @Override
     public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference) {
     	//add by James
-//        if(mRotateScreen==preference)
- //       {
-//        	handleRotateScreen();
-//        	return true;
-//        }
+        if(mRotateScreen==preference)
+        {
+        	handleRotateScreen();
+        	return true;
+        }
         //add by James
     	
         if (mToggleLargeTextPreference == preference) {
@@ -288,11 +288,11 @@ public class AccessibilitySettings extends SettingsPreferenceFragment implements
     }
     
     //add by james
-//    private void handleRotateScreen(){
-//        Settings.System.putInt(getContentResolver(),
-//           "rotate_screen",
-//           mRotateScreen.isChecked()? 1:0);
-//    }
+    private void handleRotateScreen(){
+        Settings.System.putInt(getContentResolver(),
+           "rotate_screen",
+           mRotateScreen.isChecked()? 1:0);
+    }
     //add by james
     
     private void handleLockScreenRotationPreferenceClick() {

【android42/frameworks/base/services/java/com/android/server/wm/WindowManagerService.java】
@@ -4052,7 +4052,7 @@ public class WindowManagerService extends IWindowManager.Stub
  	 if (req == ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
             req = getOrientationFromAppTokensLocked();
         }
-		req = ActivityInfo.SCREEN_ORIENTATION_PORTRAIT;
+		req = ActivityInfo.SCREEN_ORIENTATION_REVERSE_LANDSCAPE;
         return req;
 	}
     }
【注意】这些修改可能并不见得都是必须的，暂时没有副作用，暂时这样修改

apk的修改内容为，暂时在主页面的时间显示区增加点击事件，当点击发生时旋转屏幕（有点耗时，需要耐心等待）（后在参数73-LCD Inverse实现旋转）

2023-4-21 230421-31040
==================
修改当快速打印的时候，HT有切尾和Text与变量字体不同的问题。

2023-4-20 230420-31038
==================
修改HT中Text后部切尾和字体不对的问题。原因是在parseContent的时候，如果是TextObject则在setContent之前增加一个setFont。但是错误的1.tlk文件中的字体好像不可能是apk保存的。
001^031^00000^00000^00000^00000^0^000^008^2^0127400^0000000^0000000^0127400^0000000^0000000^0000000^0000000^0000000^0000^000^信息名称
002^043^00000^00000^02198^00304^0^001^000^ 1^ 2^ 3^ 4^00000000^00000600^00001200^00001800^0^99999^1+^0^1234567890^
003^001^00000^00000^02280^00000^0^001^010^000^000^000^000^00000000^00000000^00000000^00000000^002^0000^7^000^1234567890
上面的是错误的tlk文件。如果是apk保存的，肯定第二行和第三行的字体都是7（因为是16点的打印头）
因此这个修改可能没有意义。

2023-4-20 230420-31037
==================
Hp22mm库中PDGInit移植StartPrint函数，因此，PDG可以独立于IDS，PD工作。目的是为了不挂接IDS和PD硬件时能够测试FPGA

2023-4-16 230416-31036
==================
测试页面的22mm功能中，追加一个DumpRegisters的功能，用来读取FPGA当中的各个寄存器的值

2023-4-14 230414-31035
==================
修改TxtDT类的重复打印逻辑。改为，当停止打印后，再次开始打印的时候，将已经重复的次数清零，即从头开始重新计数重复次数

2023-4-04 230404-31034
==================
在230402-31033基础上，修复了HyperTextObject类中的一个错误，20230215-20230220期间为了调试，注释掉了meature函数中的o.meature()调用，没有恢复。

2023-4-02 230402-31033
==================
【临时版本】完善230331-31030版本的功能，大字机1921不锁定字体

2023-4-01 230401-31032
==================
【临时版本】在230331-31031的基础上，在RfidScheduler类中追加了墨袋机的异常读数测试功能

2023-3-31 230331-31031
==================
【临时版本】取消230331-31030对不锁定字体的修改，恢复原状，在GpioTestPopWindow类中追加一个墨袋机的测试功能

2023-3-31 230331-31030
==================
【临时版本】大字机1921不锁定字体

2023-3-27 230327-31029
==================
在230327-31028的基础上，取消先按名称名称长度，在长度相同时依次按名称各位的ASCII排序。取消按长度先排序，直接依次按位的ASCII排序

2023-3-27 230327-31028
==================
在230325-31027基础上，将MessageBrowserDialog类中的排序方法适用到loadPrevMsg和loadNextMsg两个函数的排序中，取消原来的排序方法，使得点击上下翻页时的上下页与Open对话窗中展示的信息清单的顺序保持一致。

2023-3-25 230325-31027
==================
2022-11-29 221129-30960 追加UserGroup的时候，向上翻页调用了向下翻页的函数。
ControlTabActivity.loadMessage函数中，当向前翻页的时候应该掉loadPrevMsg()，错误的掉了loadNextMsg()。

2023-3-23 230323-31026
==================
修改TxtDT类中当前当前行的显示问题，原来没有更新显示，补充进去了。并且对现实的流程做了微调，使得视觉效果更好

2023-3-16 230316-31025
==================
对于之前启用桶概念，将网络数据与桶匹配的修改未尽的地方做了补充修改，具体地方如下：
1. 扫描协议4，setScan4DataToDt
2. 串口协议8，setSerialProtocol8DTs
3. 串口协议11，setCH341DataToDt
4. QR文件，setContentsFromQRFile

2023-3-10 230310-310XX （2023-3-10 - 2023-3-13）
==================
为了对网络前置缓冲区的需求进行开发，首先对DatatransferThread类进行了相关的优化。所要达到的目的是：
1. 当apk向FPGA下发了数据以后，要实时地向PC回复onComplete(0001)回复，当前的任务已经下发到FPGA驱动
2. 当apk从img获取到empty事件的时候，向PC发送onPrinted(0000)回复，标识前面的一个任务已经打印完成
3. 当img使用FIFO的时候，会事先向img下发FIFO数量的任务，因此，会出现FIFO数量个的onComplete回复
因此，做了如下修改：
1. 将
-----------------------------------------------------------------------------------------------
// H.M.Wang 2021-5-8 试图修改根据打印次数修改主屏幕显示打印数量的功能
// H.M.Wang 2021-5-7 当在FIFO模式的时候，在这里对实际打印次数进行修正
	if(mUsingFIFO) {
		lastPrintedCount = FpgaGpioOperation.getPrintedCount();
		if(lastPrintedCount != mPrintedCount) {
			Debug.d(TAG, "lastPrintedCount = " + lastPrintedCount + "; mPrintedCount = " + mPrintedCount);
			setCounterPrintedNext(mDataTask.get(index()), lastPrintedCount - mPrintedCount);
			for(int i=0; i<lastPrintedCount - mPrintedCount; i++) {
// H.M.Wang 2023-3-10 在群组打印的时候，把打印完成的回送也移到这里，这样就不会丢掉连续的次数了，并且，这时似乎没有必要做下发数据后的后续操作
//				afterDataSent();
				if (mCallback != null) {
					mCallback.onPrinted(index());
				}
// End of H.M.Wang 2023-3-10 在群组打印的时候，把打印完成的回送也移到这里，这样就不会丢掉连续的次数了，并且，这时似乎没有必要做下发数据后的后续操作
			}
		}
		mPrintedCount = lastPrintedCount;
	}
// End of H.M.Wang 2021-5-7 当在FIFO模式的时候，在这里对实际打印次数进行修正
// End of H.M.Wang 2021-5-8 试图修改根据打印次数修改主屏幕显示打印数量的功能
-----------------------------------------------------------------------------------------------
取消afterDataSent的回送，这个主要是发送onComplete，但是onComplete在下发的时候会发送，因此不需要这里发送。
并且，增加必要次数的onPrinted回复，因为由于底层可能有数次打印被积压而没有回送消息。
2. 将原来所有情况下均回复onPrinted消息的地方，加上是否为FIFO的标识，因为如果是FIFO，则已经在修改1当中说明的那样，已经处理过了
-----------------------------------------------------------------------------------------------
	if(!mUsingFIFO) {		// 增加这个判断
		if (mCallback != null) {
			mCallback.onPrinted(index());
		}
	}
-----------------------------------------------------------------------------------------------
3. 将原来如果为非FIFO时调用afterDataSent，回送已经下发消息的处理，取消是否FIFO的判断，因为无论是否为FIFO，下发了就要回送。（代码中有两个地方）
-----------------------------------------------------------------------------------------------
//	if(!mUsingFIFO) {		// 取消这个判断
		afterDataSent();
//	}
-----------------------------------------------------------------------------------------------
4. 取消首次下发后发送回送onComplete的条件，似乎没有必要
-----------------------------------------------------------------------------------------------
//  取消这个判断              if(SystemConfigFile.getInstance(mContext).getParam(SystemConfigFile.INDEX_DATA_SOURCE) == SystemConfigFile.DATA_SOURCE_FAST_LAN) {
                     if(null != mCallback) {
                         mCallback.onComplete(index());
                     }
//                }
-----------------------------------------------------------------------------------------------

【前置缓冲区修改内容】
1. 添加一个PC_FIFO类，用来集中的处理有关前置缓冲区的功能。在这个类中完成如下功能：
   1.1 设置一个前置缓冲区，用来保存从PC端接收到为处理信息
   1.2 设置一个等待打印缓冲区，用来保存已经被下发给FPGA等待打印的信息（进保存DT0）
2. 在原有的Inquery(400)命令的应答报文中，追加一个PC_FIFO剩余空间的字段，作为对于PC查询PC_FIFO是否需要数据的回复。
    [报文示例] 0000-ok:COUNT|P1|P2|P3|P4|P5|P6|P7|P8|<T|F>|空闲位置数|原查询命令|
3. 当从PC接收到数据以后，添加到前置缓冲区的后面，并且向PC回复成功。如果前置缓冲区已经填满，则丢掉该数据，并且向PC回复失败。
4. 当打印流程从img获取到empty后，则从前置缓冲区的前部获取一条数据，解析后添加到桶中，并且从前置缓冲区中删除该条数据，同时向PC申请新的数据以补充到尾部。
    并且，将添加到桶中的数据的DT0追加到等待打印缓冲区的尾部。同时向PC发送数据已下发通知
5. 当打印流程从img获取到已经打印完成的数据数量后，会逐次从等待打印缓冲区头部删除掉，并且逐次向PC发送数据已打印通知
6. 报文
    6.1 向PC请求数据报文
	000B|0000|1000|0|0000|0|0002|0000|0D0A
    6.2 PC数据报文
	000B|0000|<600或650或REMOTE或REMOTE1>|1234,5678,,,,,,,,,www.print-test.com ,12|0|0000|0|0008|0D0A
    6.3 PC数据接受结果报文
	成功时：0000-ok: <接收到的原报文>
	失败时：1111-error: <接收到的原报文>
    6.4 数据已下发报文
	000B|0000|1000|0|<DT0>|0|0001|0000|0D0A
    6.5 数据已打印报文
	000B|0000|1000|0|<DT0>|0|0000|0000|0D0A
7. 追加一个参数，用来设置前置缓冲区的容量。0-20。当其值为0时为取消前置缓冲区，大于0时启用前置缓冲区，最大值为20
8. 增加一个网络命令，用来清除已经从PC接收到的放置于前置缓冲区的数据和已经下发的放置在img的FIFO当中的数
	000B|0000|ClearFIFO|0|0|0000|0|0000|0D0A
    (*但是，如果是正在打印当中，img的FIFO被清除之后，会立即向apk回复empty要数，这时会立即使用现有数据生成打印缓冲区，但实际上可用数据已经都清除了，因此此时的数据是无意义的数据）

2023-3-14 230314-31024
==================
关于计数细分的说明
目前存在的bug和修改说明
打印两位计数器0，计数细分设定为10，计数器0中每个数值重复打印10次

1、如果设备停止打印，计数器0的当前值变成了本次启动打印后的总计数器，计数细分的值被保存。
如：本次任务共打印十次01，十次02，五次03，此时停止打印，系统中计数器0的数值会变成25，再次启动打印后，会从25开始打印五次，再接着打印26

需要改成
除修改计数器当前值的操作以外，所有停止打印的操作都会保存计数器为当前打印的数值并同时保存计数细分为当前值；
用户在停止打印修改参数后，再次启动打印，会继续上一箱的数值打印。

2、修改计数器的当前值，计数细分的值没有重置
目前的状态：当修改计数的当前值时，计数细分没有重置
如：本次任务共打印十次01，十次02，五次03，此时修改计数器当前值为1，设备会继续打印上一组03的计数细分的剩余数量，打印五次01，再接着打印十次02

需要修改为
只要修改计数器的当前值，则计数细分重置，新计数器值和新计数细分数同时生成。

【吕总描述】
按停止， 细分归零，  存当前值。
不按停止， 改计数， 也是先细分归零， 存新输入的数字

对以上需求进行修改。

2023-3-09 230309-31023
==================
在230309-31022版本基础上做如下修改：
1. 在readTxtFile函数中追加
            mPrintRptCnt = 0;
   目的是如果更新了文件，则从头开始重复打印（忽略掉以前打印过的次数。如果是简单的停止打印，然后再次开始打印，则会继续前面的次数进行重复打印）

2023-3-09 230309-31022
==================
修改mRepeatCnt的获取方法，还是在afterTextChanged当中设置，但是只有在该控件的Enabled为true时才有效（此时没有开始打印，开始打印后为false）

2023-3-09 230309-31021
==================
1. 取消230228-31018版本打开的1207通道，回复到原来的通道。
2. 在TxtDT类中，取消afterTextChanged函数中修改mRepeatCnt，因为这个可能导致在打印过程当中使得mRepeatCnt被中途数据修改。
3. 对于HP22MM的修改保留，因为不会影响其它的正常功能

2023-3-05 230305-31020-HP22MM_Test【HP22MM测试版本】
==================
1. 取消230304-31019中屏蔽其它so文件复制的操作，相当于在原有的复制so操作后面，追加了一个复制libhp22mm.so的操作，以前这个操作是失败的，现在看能够成功，需要验证。
2. 在测试页面当中的init IDS和init PD中追加了当前hp22mm库版本号显示

2023-3-04 230304-31019-HP22MM_Test【HP22MM测试专用版本】
==================
取消了其它so的从asset目录拷贝到/system/lib目录的操作，只保留libhp22mm.so的复制

2023-2-28 230228-31018【1207测试专用版本】
==================
1. 在ExtGpio类中追加一个RFID_ACCESS_LOCK，用来保护N_RfidScheduler类和N_RFIDManager类中，切换RFID头（ExtGpio.rfidSwitch(i)）以及后续的RFID读写操作（或者借助于切换头后对墨袋的访问），使得切换头和使用头在一个原子操作区间内，不被打断，否则可能会张冠李戴。
   并且，在N_RFIDManager类中，取消根据当前头即目标头是否一致而决定是否切换头，因为这里即使是一致的，但是可能在N_RfidScheduler中已经被切换过了，所以可能还是会出现张冠李戴的问题。
2. 在SettingsListAdapter类中，追加两个成员变量
	private Drawable mLeftDrawable;
	private Drawable mRightDrawable;
用来记忆显示设置内容的TextView右侧的那个小箭头。因为这个箭头会在当设项为DIALOG时，被设为null，导致后续即使这个显示控件被再次使用给SWITCH类型，也不再会显示这个箭头了。因此这里需要修改为如果后续是SWITCH时，要设置回来
3. 打开230215-31014版本关闭的1207通道，方便对1207进行彻底测试。

2023-2-23 230223-31017
==================
修改C63的计算公式，改为 C63 = (param[SystemConfigFile.INDEX_WARMING] - 7)/2，但不能为负数。

2023-2-20 230220-31016
==================
对于网络打印任务（10DT+1DBAR）的速度提升，做了两项改进：
1. 当DT或者Barcode的动态内容发生变化的时候，不在setDTBuffer或者setBarcodeBuffer中直接写入Prefs，而是设置一个脏标识，待后续线程写入。这个写入线程借用了ControlTabActivity当中监视心跳的线程
2. 事先生成一个具有一定空间的pixels数组，在实际使用时，如果需要的空间在此范围内就不再申请空间，而是直接使用这个预先申请的空间，目的是避免运行时频繁申请内存而导致系统启动内存清理(GC_)而额外消耗时间

2023-2-15 230215-31015
==================
1. txt文件打印(UserMode3)的预览窗从3行改为2行
2. 将打开文件改为打开模板，并且将模板的名称小字显示在其下面
3. 取消在状态条原来的上下移动按键，因为此模式没有必要切换信息文件。使用此空间显示打印计数器
4. 将原来通过Config文件切换用户的工作模式（需要重新编译）改为通过参数71（名称为：快捷模式/Easy mode）切换。
5. 修改用户模式2的layout文件，因为后来修改过标准工程的layout，用户模式2与标准模式共用代码，因此如果不修改会在模式2的时候出现死机。具体修改的位置是：
   状态条替换成标准的layout中的内容。信息名称栏中的打印状态（右侧部分），这部分取消了剩余次数（剩余次数移到了状态条的各个头剩余墨量后面），并且将状态条的电压和脉宽已到了这里。

2023-2-15 230215-31014
==================
1. 关闭230214-31011版本打开的1207通道，恢复到原来的RFID通道。
2. 修改txt文件打印的文本解析方法，取消230214-31013第1条的修改。改为以逗号为分隔符，前10个赋给DT0-9，第11个赋给动态条码（与当前网络和串口的用法一致），这些值将被用在模板信息的DT和条码变量中

2023-2-14 230214-31013
==================
1. 修改txt文件打印，每行不设序号，所有内容为打印内容。放在DT0当中
2. 增加了QR码的纠错级别（待完善）

2023-2-14 230214-31012
==================
1. 修改几处230213-31010版本中对txt文件操作的bug：如下
  1.1. 打开txt文件选择清单没有去掉目录，看着很多，竟是没用的
  1.2. 循环打印图标显示有误
  1.3. 预览显示不及时，不更新等问题。
2. 将Bagink的支持移植到了N_Scheduler类中，与Scheduler里面实现的Bagink的功能做了一些小改动。
   即：在schedule函数中增加一个3000ms的静默期间，这个与原来的类有不同

2023-2-14 230214-31011
==================
在230213-31010版本的基础上，将2023-2-2 230202-30998时关闭的1207通道再次打开，以供测试。新的1207通道还没有继承Bagink的功能，需要注意。

2023-2-13 230213-31010
==================
追加一个支持从U盘的txt文件中读取内容进行打印的版本。具体说明如下：
1. 暂时使用数据源Disable作为启动的标识
2. 对主页面进行重组，关闭信息名称横栏，将打印、停止，清洗，打开按钮移到屏幕下方在原地追加操作txt文件属性的区域
3. 在txt文件属性区，追加一个文件名显示区，显示选择的txt文件，点击此空间可以选择U盘中其它txt文件。选择txt文件后，可以显示行数
   并且，可以显示和修改开始行，结束行，当前行，重复打印次数以及循环打印等属性。

具体操作：
1. 首先需要点击open按钮选择一个包含DT的模板文件（最简单的就是一个DT）
2. 点击文件名显示区，选择一个txt文件，选择以后，开始行=1，结束行=行数，当前行=1，重复次数=1，不循环打印。这些属性可以修改
3. 点击打印按钮开始打印
4. 预览区显示当前行的信息，并不是像以前一样显示打印信息的内容

2023-2-10 230210-31009-21x21
==================
【临时版本】QR取消32点强制使用29x29。纠错级别M

2023-2-10 230210-31008-QRQ
==================
【临时版本】QR纠错级别Q

2023-2-10 230210-31007-QRH
==================
【临时版本】QR纠错级别H

2023-2-9 230209-31006-sc-bulk-skip
==================
【临时待确认版本】在hw_smart_card_proto.c中的_recv_rsp函数中，跳过HW_SMART_CARD_failed_e错误。31004版本作废

2023-2-9 230209-31005-sc-pen
==================
【临时版本】墨盒代替墨袋的特殊版本

2023-2-9 230209-31004-sc-bulk-skip
==================
【临时待确认版本】在hw_smart_card.c中，跳过HW_SMART_CARD_failed_e错误

2023-2-6 230206-31003
==================
31002版本中的S11的计算有误。
S11[7-3] = C63/2。而不是S11[7-3] = C63

2023-2-4 230204-31002
==================
修改参数C62及参数C63的用法。
参数C62修改为：加热限制/Warm limit。单位 分钟/min，取值范围0-7，默认0
参数C63修改为：温度/Warming。单位℃，取值范围0-40，默认0
同时，取消220825-30911版本追加的C62的使用方法。
同时，取消参数C63在扫描数据处理(DataTransferThread.setScanDataToDt)函数中作为dt34的基数的使用方法。

2023-2-3 230203-31001
==================
30999版本只修改了一部分内容，使得2个P和B能够正常显示，但是1个P和B的时候，B所在的区被设置为View.GONE了，这样就不显示B了。在refreshInk函数中增加了
		if(mInkManager instanceof SmartCardManager) {		// 当初始化这些显示控件的时候，还没有初始化SmartCardManager，因此还无法获得正确的heads，因此在这里再根据实际SC的头数调节控件的显示属性
			heads = ((SmartCardManager)mInkManager).getInkCount();
（这次增加这行）			if(heads >= 2) mInkValuesGroup2.setVisibility(View.VISIBLE);	// 流出显示B的位置
			if(heads == 3) mInkValues[heads].setVisibility(View.INVISIBLE);	// 占个位置，不实际显示
		}

2023-2-2 230202-31000
==================
1. 在保存的时候，先清除现有内容，然后在保存，一面现有内容成为僵尸文件，也许会影响到打印内容（吕总那里有保存后打印不全的问题，我这里没有发现）。但是，由于图片文件原来是复制过来的，这样删除以后就会丢失，因此改为直接保存图片的方法。

2023-2-2 230202-30999
==================
30998(1)只修改了SC的B头不显示的一个问题，还有一个问题是，在初始化的时候，将正常RFID头的后面无头部分的显示控件全部设为View.GONE了，因此，SC的时候B的显示空间为GONE。
修改的逻辑是，在refreshInk，在显示的时候，将有数据的部分设置为View.VISIBLE，这样就可以把初始化的时候关闭的B空间打开显示了。其次，在两个P头的时候，P2的显示由于在第二列，而第二列只有一个控件P2，因此，这个P2控件会纵向
居中显示，不美观。因此，在refreshInk函数中，如果是SC卡，并且头数为3（即PPB的组合）的时候，将控件3（B后面的控件，P2下面的控件）设置为INVISIBLE，即不显示，但占位。这样就避免了P2纵向居中的不协调了。

2023-2-2 230202-30998
==================
1. 修改SC的B头不显示的问题，原因是修改refreshInk函数的时候，没有将原来根据SC头或者RFID头的区别分别获取头的方法完全一致过来，丢掉了
		if(mInkManager instanceof SmartCardManager) {
			heads = ((SmartCardManager)mInkManager).getInkCount();
		}
调用（refreshInk函数)，补充进去了。
2. 修改BarcodeObject.java类中的getPrintBitmap函数，取消原来调用getScaledBitmap，同时取消对Bitmap的变换大小(Bitmap.createScaledBitmap)，因为这样会使得处理速度变慢，而且会导致二维码变形而无法识别。
    新的实现方式是，在新的getPrintBitmap函数中，直接按着实际的宽和高生成需要打印的Bitmap（原来的实现方式是先生成152高的图，然后再变换到目标大小），这样就避免了上述两个问题。
    经过测试，提高处理速度10-20ms，并且不再发生变形
3. 当打印头是32点头的时候（高为32），强制生成版本3的QR码，其大小为29x29，目的是尽量减少二维码周围的空白。因为否则的话，可能会生成21x21（大部分情况字符数较少，就会这样），导致周围空白很多

2023-1-28 230128-30997
==================
1. 修改1207卡initCard函数，增加读Max和InkLevel的调用，以保证被initData清零的 mBlockCnt，mPageCnt，mByteCnt，mBitsCnt得到重新计算，否则会导致在已经写过的地方再次写入
2. 修改几处log输出

2023-1-18 230118-30996
==================
1. 在controlTabActivity里的refreshCount函数（这个函数会在系统启动之后被调用）中，增加一个再启动时间50000ms后才调用refreshInk的功能，否则可能会由于执行太早，而RFID数据没有准备好而发生误报警
2. 在N_RFIDDevice的写函数中，追击一个如果写失败，则尝试10次的机制，以避免偶然的写失败导致误报警

2023-1-18 230118-30995
==================
1. 取消30994版本的2，重新注释掉initCount中队计数器和阈值的赋值，因为这个赋值在打印缓冲区生成完之前使用的是TLK文件中的点数作为依据，可能被篡改，这样同样会发生无法预期的剩余次数跳数的问题。
   改为在PrintTask的线程里面，生成完打印缓冲区后（此时，点数会根据实际情况更新），重新计算一下阈值和内部计数器，这样的结果就准了。重新计算使用新加的函数recalCount
2. 在controlTabActivity里的refreshCount函数（这个函数在每次触发打印后，都会被调用）中，追加一个检查上次显示时间的功能，如果上次显示时间与本次的时间不超过100ms就跳过不再显示，目的是避免频繁显示带来的系统负担

2023-1-17 230117-30994
==================
1. 脉宽单位修改为μs
2. 暂时恢复initCount当中对计数器和阈值的赋值，再看看后续有没有问题
3. 暂时取消根据NNM2启动N_RFIDManager和N_RFIDDevice的初始化，这样的话就全部启用N_系列了，有N_系列自动查找RFID模块的种类
4. 增加N_系列当中写卡操作失败时mValid设为false的功能。这样就会在打印中如果拔卡就会报警，但是此时是否停止打印需要讨论
5. 在N_RFIDManager类中的Timer里面，只有在需要写操作的时候才尝试切换RFID，否则不切换，以避免频繁切换。

2023-1-17 230117-30993
==================
1. 对主页面进行修改，将一些显示元素调位。主要内容是：
  1-1 将电压，脉宽显示从画面的底部转移到打印计数器的左边，以V和us为单位，对数据的小数点进行调整后显示
  1-2 将电量存量图标移到画面的右下角，向左以此为打印状态显示及上下选择按键
  1-3 画面底部左侧显示锁值剩余百分比及剩余次数，显示格式为（例）：P1-100%-12345678
     1-3-1 当画面为3.5寸时（此时只有一个头），以居左纵向中间对齐显示，字号为50sp
     1-3-2 当画面为5寸时（此时头最多有两个），以居左纵向中间对齐，两个头时，上下排列显示，字号30sp。此时的排列顺序为
              |  1  |     |
              |  2  |     |
     1-3-3 当画面为7寸时（此时头最多有6个），以居左先横向，后纵向排列显示，字号为25sp。此时的排列顺序为
              |  1  |  2  |
              |  3  |  4  |
              |  5  |  6  |
  1-4 修改内容
      主要对control_frame.xml的布局做了多处调整，具体调整内容由于比较繁多，没有在代码中注明，需要与之前的版本对照检查不同点。
      相应的对controlTabActivity的空间显示内容做了修改。
2. 修改剩余次数显示策略
    从之前的每次计算getInkThreshold，修改为只是取得已经计算得到的数值，还是为getKeptInkThreshold，该函数返回在开始打印后计算得到的每个头的阈值。
3. 修改打印信息显示策略
    3-1 每次打印一次后，显示打印计数，同时显示锁值和剩余次数，这样剩余次数会显得比较连贯，以前是每3秒显示一次，打的快的时候，数字不连贯。主要修改refreshCount函数
    3-2 显示剩余次数的地方，同时显示所有头的信息。主要修改refreshInk函数

2023-1-13 230113-30992
==================
根据img的版本来判断是否启动N_库（NNM2类型img）还是原有库（其他img），并且NNM2类型img时，仅启动1207模块，换言之，NNM2img仅支持1207卡

2023-1-13 230113-30991
==================
大幅修改了RFID的功能部分。主要的内容是：
1. 创建了下列新的类：
    1.1 N_RFIDSerialPort
        用来实现串口的通讯，在函数架构上apk与pc采用一样的架构，但是实现上各自的具体实现方法不同
    1.2 N_RFIDModule
        通讯模块的基类，用来定义不同模块需要遵循的函数接口
    2.3 N_RFIDModule_M104BPCS
        实现M104BPCS（PC上制卡时使用的模块）的通讯功能
    2.4 N_RFIDModule_M104DPCS
        实现M104DPCS（打印机上使用的定制模块）的通讯功能
    2.5 N_RFIDModule_M104BPCS_KX1207
        实现M104BPCS_KX1207模块（打印机上使用的另外一种定制模块）的通讯功能
    2.6 N_RFIDModuleChecker
        自动判定模块种类的工具类
    2.7 N_RFIDData
        对原有RFIDData进行了优化，功能是编码送信报文和解码收信报文
    2.8 N_RFIDManager
        是对原有RFIDManager类的优化。原有类在处理RFID的通讯事件时，是通过消息将不同步骤进行链接的，弊端是把本应在一起的处理割裂开来，使得修改，维护和理解都比较困难
    2.9 N_RFIDDevice
        是对原有RFIDDevice类的优化。
    2.10 N_RFIDScheduler
        是对原有RFIDScheduler的精简。因为原来的机制是通过该类启动对RFID的锁值写入，不仅流程有问题，并且还会产生多次不必要的写入操作
2. 实现机制的答复修改
    2.1 首先是保证不同种类的模块和卡的处理，尽量抽象出来有共性的处理内容，作为一个处理模型。该模型分类两个级别。
         首先是对于锁值的相关处理的逻辑模型，主要定义在N_RFIDDevice当中。
         其次是将面向不同的模块进行的相同意义的访问接口统一，具体实现根据不同的模块具体实现。这个主要是定义在一个抽象类N_RFIDModule中，具体由继承该基类的各个类实现，如
         N_RFIDModule_M104BPCS， N_RFIDModule_M104DPCS， N_RFIDModule_M104BPCS_KX1207
    2.2 首先是尽量保证制卡工具与使用库之间，抽象的RFID卡处理部分尽量保持一致
    2.3 通讯部分的驱动独立到一个同名，同架构的类N_FRIDSerialPort
3. 新的架构的有点是逻辑性强，易扩充，以维护，易理解。但，当前为保证原有功能的稳定性，暂时与原有实现方法共存，待新功能稳定性得到确认以后，会逐步全部切换到新的模式下，废弃掉原来的
    代码。当前暂时共存，原有功能仍然使用原有部分。新的1207功能使用新的部分。

【注意】
    该版本仅使用新的实现逻辑，无论在原有的DPCS模块（S50卡），还是新的1207模块和卡上面都只能走新的处理路径，因此可能会有一些问题。

2023-1-11 230111-30990
==================
对于2022-12-1日push的30955-30962版本之间做的关于DataTask类中的refreshVariables函数里面，当变量为RealtimeObject和HyperTextObject，贴图开始开始位置做的修正
原来是
	BinInfo.overlap(mPrintBuffer, var, (int) (htObj.getX() / div), info.getCharsFeed() * stat.getScale());
修改为
	BinInfo.overlap(mPrintBuffer, var, (int) ((htObj.getX()+o.getX()) / div), info.getCharsFeed() * stat.getScale());
增加了一个+o.getX()的调整，因为在横向出现第二个变量的时候，图会贴错地方。
但是，这个修改导致，第一个日期变量的贴图位置不正确，子信息的X位置是已经加了母信息位置的，这样会加两次母信息的位置，导致贴到后面（当然，如果母信息的开始位置是0则看不出影响）

所以还得再好好分析一下，如何把第一个日期变量不开始于0位置（不要加母信息的起始位置进行调整），和第二个日期变量需要调整，否则贴错位置（需要加母信息的起始位置进行调整）结合起来处理

2023-1-7 230107-30989
==================
取消打印时向FPGA下发参数（在打印状态下，如果修改参数，并且保存，会选择合适时机下发参数给FPGA，这个操作取消）

2023-1-6 230106-30988
==================
取消64DOT打印头的旋转功能，在PrinterNozzle.java类中，64DOT时将buffer8Enable设为false，就可以取消旋转功能

2023-1-5 230105-30987
==================
1. 取消开始打印命令下发后立即将GPIO切换到 FPGA_STATE_OUTPUT(00)，因为这会导致PH14立即发生，此时有可能数据还没有准备好，改为开始打印后第一次下发数据后切换
   涉及FpgaGpioOperation.java类
2. 增加一个快速打印(Fast Print)的参数。通过S24[4]下发给FPGA
   涉及SystemConfigFile.java类，Paramter.java类，SettingsListAdapter.java类，以及strings.xml

2023-1-4 230104-30986
==================
追加一个参数步长细分/Sub step。其功能是决定计数器在打印过程中何时进行调整，n=0或n=1为每次打印均调整，n>1时为打印n次后调整。
涉及到SystemConfigFile.java类，CounterObject.java类及strings.xml文件。

2022-12-29 221229-30985
==================
Bagink测试页面的设置I2C Flash(HX24LC)对话窗中，追加一个Write按钮，当按键为OK->Write->OK的顺序时，启动设置，否则忽略。

2022-12-28 221228-30984
==================
Bagink在开阀加墨以后，清空记录的墨位数据，重新开始10次取数看平均值是否低于阈值，再次判断是否需要开阀加墨

2022-12-28 221228-30983
==================
1. 增加打印时检查Bagink的Level值时，减去HX24LC的读取值。
2. 增加显示读值时同时显示HX24LC的读值

2022-12-26 221226-30982
==================
增加HX24LC的读写测试功能。放在Bagink的测试页里面

2022-12-22 221222-30981
==================
在MainActivity类中，切换到设置参数的Fragment时，更新一次版本号显示的内容，因为最近增加了FPGA的版本号显示，在最初构建控件时设置的版本号信息中，还无法包含FPGA的版本号，因为从FPGA获取的时候，FPGA驱动可能还没有机会从FPGA中获取该信息。
因此，在每次设置参数的Fragment被调度到前台的时候，再次获取一次显示就能解决这个问题了。
在onCheckedChanged函数中的case R.id.btn_setting:下面追加一行
	mSettingTitle.setText(PlatformInfo.getImgUniqueCode());

2022-12-22 221222-30980
==================
1. Barcode的反白设计。在条码类型的变量属性编辑窗中，添加一个反白的Checkbox，用来指定是否反白。当指定为反白时，将生成的QR图黑白倒置
2. 对于单点打印做以下修改：
   2-1 任何时间只要有PC数据从串口传入，即接收保存，待打印时使用
   2-2 增加串口返回信息机制
      2-2-1 当接收到的数据长度不足时，返回
	ER-01-<原数据>
      2-2-2 当接收到的数据长度不匹配时，返回
	ER-02-<原数据>
      2-2-3 当接收到有效数据时，返回
	OK-01-<原数据>
      2-2-4 当有效数据完成打印时（以FPGA请求数据作为上次打印完成的判定标准），返回
	OK-02-<原数据>
   2-3 增加打印缓冲区的变形
      2-3-1 当参数1（打印方向）与参数13（打印头1镜像）均为1或者均为0时，正向打印，否则反向打印
      2-3-2 自动倾斜，每列间插入空白列，使得原相邻列之间相隔32列

2022-12-20 221220-30979
==================
该修改从2022-12-19 - 2022-12-20完成，查找修改内容时，需要查这两个日期
增加RS232单点（）RS232DOT的新串口功能，具体规则参见《单点机通讯.doc》。设计Serial包和DataTransferThread类，以及各语种arrays.xml文件

2022-12-18 221218-30978
==================
将schedule函数中读取Level的功能部分移到loadNext之前，同时在读取Level函数执行完成之前，等待。

2022-12-16 221216-30977
==================
取消30976的log输出，将schedule函数中Bagink的操作移到loadNext之后，并且尽量不影响他的操作。

2022-12-16 221216-30976
==================
临时增加一个log输出，查看在shedule函数被调用时，指向的是哪个头和头的数量

2022-12-15 221215-30975
==================
Bagink的Level与打印头的对应关系改为L1234 vs 头1342

2022-12-15 221215-30974
==================
两次开阀的时间间隔3秒搞错了，应该是2分钟

2022-12-15 221215-30973
==================
1. BAGINK的Level信息对话窗中，显示的加墨时间由当前时间改为加墨时间（原来就是这么想的，变量加错了，写成了System.currentTimeMillis()，应该用mInkAddedTime[i]
2. 在上次开阀后，3秒之内不在开阀，即使检测到墨位低也不开阀
3. 读取的Level数据无论是否为有效数据，均收录，并且显示在对话窗中，便于用户监测到。但仅有效数据参与计算，当有效数据达到10个后，计算其平均值，低于380开阀加墨
4. 为了防止切换头后电信号不稳定，切换头后等待100ms再开始读取Level数据

2022-12-15 221215-30972
==================
在ControlTabActivity类中，响应GIPO的输入，完成C57设置的协议的代码中，如果是P-1以外的协议，会主动生成一个DataTransferThread类的实例，但是DataTransferThread的初始化中会初始化UI功能相关的Handler和AlertDialog，
这样就会导致在线程中生成UI的错误而发生异常。修改为：使用类内的成员变量mDTransThread，凡是涉及到DataTransferThread类实例内的内容的操作，视其是否为null，如果为null的不动作，非null则动作。如果是启动打印，则如果
为null，则直接模拟开始按键按下，如果不为null，则按原来逻辑处理。
具体修改内容为：
//					final DataTransferThread thread = DataTransferThread.getInstance(mContext);
注释掉该行，下面使用thread变量的代码，改为使用mDTransThread，并且判断mDTransThread是否为null，如果不为null找原来的正常逻辑操作，如果为null，则根据null时需要的操作，做具体的处理，多处修改未标注

2022-12-14 221214-30971
==================
RfidScheduler类中有关BAGINK的功能做一下改良：
1. 如果连续3次的读数都低于正常最低值，则报警三声，显示提示窗
2. 如果连续3次的读数都高于正常最高值，则报警三声，显示提示窗

2022-12-14 221214-30970
==================
RfidScheduler类中有关BAGINK的功能做一下改良：
1. Level读数之前，切换Level后，睡50ms，等待信号平稳
2. 如果连续3次的读数都不在正常范围内(330,560)的话，报警一次
3. 每次的读数如果不在正常范围内的话，仍然记录，但不参与对是否开启开阀的计算
4. 当记录数据达到10个的时候，计算所有记录的有效数据的平均值，如果没有有效数据，采用最大值560
5. 加墨逻辑
    要求：检测到LEVE 数值：10次低于：380或380时， 阀开 3次  ， 开阀后在检测LEVE 数值：10次低于：380或380时，阀开，循环 3次检测。检测如果还是低380视为墨袋空，报警。
    实现：记录数据达到10个的时候，计算有效数据的平均值，如果平均值小于等于380，则开阀加墨。如果连续3次加墨后仍然不能大于380，则报警。
    ！380为加墨阈值

2022-12-13 221213-30969
==================
1. 固定30968修改的内容
2. 在RfidScheduler类的readLevelValue函数中，调用SmartCard.readLevelDirect函数前切换到通向Level的头，执行完成后，再恢复到当前卡的头选

2022-12-13 221213-30968
==================
1. 临时在RfidScheduler的init函数中，2022-10-28日追加的，对mBaginkImg的一系列初始化操作提到load()函数调用之前，以避免其中对ExtGpio.rfidSwitch(mLevelIndexs[i])的调用，将load函数中已经设置好的当前头改变
2. 临时将Level的L1，2，3，4修改为对应卡1，3，2，4。RfidScheduler和GpioTestPopWindow两个类中的都做修改

2022-12-09 221209-30967
==================
修改BAGINK的合法上限值和加墨阈值：
VALID_INK_MAX: 37000000 -> 56000000; 
ADD_INK_THRESHOLD: 34700000 -> 38000000

2022-12-05 221205-30966
==================
1. 修改ControlTabActivity类中的 switchRfid 函数及 refreshInk 函数中对于SmartCardManager的元素数量的访问方法，
   取消 ： mSysconfig.getPNozzle().mHeads
   改为 ： ((SmartCardManager)mInkManager).getInkCount()
   改前的方法，依赖于SmartCardManager是根据打印头为12.7类型则作为1墨盒+1墨袋，12.7x2类型则为2墨盒+1墨袋，但是如果选择了其他类型的打印头，如1英寸x2类型的打印头，会导致实际生成的数量和访问的数量不一致，导致访问时数组越界而死机
2. 在PrinterApplication类中，增加一个 ExceptionInInitializerError 异常的捕获，通用的Exception无法捕获，而导致loadLibrary函数中无.so库时发生异常

2022-12-05 221205-30965
==================
25.4 的喷头， 不管双列偏移设了什么， S18[4]=0

2022-12-04 221204-30964
==================
FpgaGpioOperation在下发FPGA参数的时候，原来无条件将双列C61参数通过S26参数下发，修改为，只有在12.7x1,2,3,4打印头时下发，其他打印头的时候不下发（即下发0），表示其他的头不支持双列

2022-12-02 221202-30963
==================
恢复30959版本修改的墨盒代替墨袋的版本回到墨袋

2022-11-30 221130-30962
==================
1. 修改UserGroup开始打印时死机的问题
2. ENC_FILGER(ENC滤波)修改为：S24[15:8] = （1204.77 - C67) / 4.77。但如果C67=[0-9]，则S24为0。C67的取值范围改为[0-1200]，附加显示单位p/s，脉冲/秒

2022-11-30 221130-30961
==================
1. 修改30960版本直接保存UG类型信息并且启动打印的时候死机的问题，问题出在此时没有子信息，子信息数组为null，修改为放回一个包含0个元素的数组，并且数组元素为0时，不启用子信息的打印，而将母信息看作普通信息打印
2. 增加参数68，ENC Dir。其值为：0-None; 1-Left; 2-Right。并且的下发参数是以此修改S24的[3:2]位。00-None; 10-Left; 11-Right。

2022-11-29 221129-30960
==================
追加UserGroup信息类型，用来处理用户的特殊要求。本修改从2022-11-26至2022-11-29期间作业，可以根据该期间的日期查询修改的具体内容。修改内容的说明如下：

1. UserGroup信息的编辑
   在编辑页面，通过添加超文本的方法编辑信息。如在HyperText的内容编辑框内嵌入
   This is @UG.
   那么@UG就代表User Group当中使用的用户通过U盘提供的字符串

   * 一个信息当中，有且仅有一个@UG，如果出现多余的@UG，其打印内容与第一个@UG完全相同

2. UserGroup信息的保存
   当用户点击保存或者别名保存的时候，文件名必须以
   "UG-"
   为开始，后面附加上用于区别不同文件的名称。

3. UserGroup信息的选择
   可以通过选择信息对话窗选择相应的信息，或者点击上下滚动键选择UserGroup。当UserGroup信息被选择之后，点按下滚按钮选择改UserGroup文件所包含的所有子信息，然后通过点按上下滚动键选择具体的子信息。

4. 替换信息格式
   替换信息文件名固定为：UG.txt
   保存在U盘的根目录下。
   格式(示例)：
      1,AAAAAAAA
      2,BBBBBBBBB
      3,CCCCCCCC
      其中，1,2,3代表行号，对应于后续生成的子信息的文件名；AA.., BB.., 代表信息的具体内容

5. 替换信息的导入流程
   根据下列步骤导入：
   5-1 使用选择信息对话窗或者上下滚动键，选择一个UG信息文件；
   5-2 点击屏幕右上角的传输按钮（所有箭头图标），在提示信息中选择 "Import UG"，启动导入
   5-3 启动导入后，会显示信息框提示“Copying, please wait”提示窗，并且显示转轮等待图标
         （此时后台将UG.txt中包含的所有条目，每行作为一个子信息导入到当前的UserGroup信息，并且相应生成子信息，按序号保存）
   5-4 导入完成后，信息框关闭

6. UserGroup信息的打印
   通过第3条说明的方法选择一个UserGroup信息后，点击打印按钮，从上次结束位置开始打印子信息。如上次停止在第n-1条信息，则从第n条开始打印。新信息从首条子信息开始打印

7. 选择子信息开始打印
   通过第3条说明的方法选择一个UserGroup信息后，点击下滚按钮选择欲打印的子信息序号后，点按开始打印按钮，则从该子信息开始打印
      
2022-11-28 221128-30959
==================
临时版本，使用墨盒代替墨袋

2022-11-26 221126-30958
==================
增加S24下发参数的BIT2，参照C2，如果C2=0(Left)，S24[Bit2]=0; 如果C2=1(Right)，S24[Bit2]=1

2022-11-25 221125-30957
==================
当前的策略是保存最新的内容（可能是编辑页面返回的内容（也许是连续的#，也许是有DT的桶取来的内容），也可能是DT桶取来的内容），总而言之，内容是固定的。
这样，在生成编辑页面的图片或者打印图片的时候，总是生成一样的图片。但是，如果内容的后部分是空格（位数大于实际输入的内容的个数），那么，编辑页面后面
就看不出还有内容，操作人员容易将后续的变量与改DT重叠；但是如果后面简单的加#，虽然可以避免编辑页面的误操作，但是打印出来的话，会出来多余的#，不美观。
因此，做如下修改：
1. 这里保存的内容（mContent)均保存足位的#，setContent函数会给父类函数传递这个足位#的字符串，所有通过getContent获取内容的函数均会得到该结果
2. 在生成打印图片的函数里（getPrintBitmap），忽略掉内部的mContent，而是从桶中获取相应的内容，如果这个内容不为空，则后面添加空格后作为打印内容使用；
   如果桶中无内容，则去掉添加的空格后为空，这时使用内部内容的足位#字符串作为打印内容
修改的文件为DynamicText.java了，有多处修改，未作日期标注，主要涉及setContent，getContent，setBits和getPrintBitmap函数

2022-11-24 221124-30956
==================
修改221119-30952版本修改时的修改错误，导致主页面的时间不显示了。

2022-11-24 221124-30955
==================
追加参数67，ENC滤波/ENC Filter。实际下发S24=C67*1/2

2022-11-21 221121-30954
==================
将阿拉伯文的字符串(strings.xml)放在英文（新加坡）语言类中看看效果。

2022-11-20 221120-30953
==================
继续解决切换到阿拉伯文时的画面显示问题，主页面下部显示错误：
1. 修改control_frame当中的ctrl_stateview段，改为Linear Layout，内部的具体内容酌情进行了修改和调试
2. Java代码中的String.format会产生乱码（可能是"0,1f"这个格式定义带来的问题），对于ControlTabActivity.java类中的相应显示ink百分比的地方做了修改

2022-11-19 221119-30952
==================
解决了切换到阿拉伯文的时候，画面显示的一部分问题。
1. 主页面的transfer键显示错位的问题
   原因是activity_main.xml当中，几个extra显示部分使用了RelativeLayout当中的toRightOf属性，切换到阿拉伯文的时候，画面会左右颠倒，但是toRightOf和toLeftOf这些属性还是按着左右做调整，原来正常显示的内容就出现差错了。
   通过调整布局的方式，使用了toRightOf或者toLeftOf的地方，将RelativeLayout改为LinearLayout了
2. 编辑页面下面两行按钮右侧（阿拉伯文时的右侧）两个按钮显示缺失的问题
   问题出在两行按钮的定义文件，edit_small_button.xml和edit_small_button2.xml中的下属两个属性的定义
	android:divider="@drawable/divider"
	android:showDividers="middle"
   取消这两个属性的定义，通过每个元素当中增加margin的方式从视觉上分开不同的按钮
3. 设置页面的apk版本不显示的问题
   原因与问题1相同，参照问题1的修改

2022-11-16 221116-30951
==================
取消210726-30673版本修改1，去掉重复打印时点数的倍数计算，因为生成打印缓冲区的时候已经按倍数生成，点数已经加倍，这里再进行倍数计算会出现被扩大的问题，如重复打印10次，如果加进去这个点数的倍数计算，会被两次乘以10，而得到100倍

2022-11-15 221115-30950
==================
取消2022-11-5 30933版本的修改3，即对mPower的启用和根据img的类型决定是否显示(电池图标，电压和脉宽全部受控)，而改为如果是M5/M7/M9/BAGINK/22MM/Smartcard的img时，不显示电池图标，电压和脉宽继续显示

2022-11-12 221112-30949
==================
增加24字体

2022-11-12 221112-30948
==================
1. 增加32点打印头的一个24行高，不绑定字体
2. 修改Bagink的有效值上限值为370

2022-11-11 221111-30947
==================
由于Feature参数是一个字节的，因此在制卡的时候，设置347会发生溢出，仅存留(347-256=91)，因此，在本例使用的时候，使用读到的数值加上256即可以得到原来想要的值(如，347)，按此修改

2022-11-10 221110-30946
==================
1. 追加RfidScheduler在初始化的时候，BAGINK功能启动时，如果读取的Feature6的值不合法，则向DataTransferThread类发送错误时间，DataTransferThread类在接收到该错误事件后，启动停止打印的操作，为此，为public interface Callback增加了一个onError的回调接口函数。
2. 修改读到的LEVEL值，在正常范围内报警的问题。

2022-11-10 221110-30945
==================
解决显示Level信息框时死机的问题，由于增加显示开阀加墨时间导致

2022-11-10 221110-30944
==================
1. 改为如果readLevel值不在330-360之间三次，则报警
2. 如果Feature6阈值不再330-360之间报警

2022-11-10 221110-30943
==================
1. 如果readLevel值不在330-360之间，则报警
2. 即使readLevel值不在330-360之间，也显示，但不参与平均

2022-11-10 221110-30942
==================
增加了几个Debug输出

2022-11-10 221110-30941
==================
修改bug

2022-11-10 221110-30940
==================
1. RfidScheduler.java类中Level的值的有效范围由[120, 160]改为[330,360]
2. 增加开阀加墨时间的记录和提示窗显示

2022-11-10 221110-30939
==================
修改SmartCardManager写OIB判断条件的bug，
                    if(mCards[mCurBagIdx].mInkLevel / mCards[mCurBagIdx].mMaxVolume < 0.05f) {
改为
                    if(1.0f* mCards[mCurBagIdx].mInkLevel / mCards[mCurBagIdx].mMaxVolume < 0.05f) {
少了浮点运算的转换，否则，直接变成0了。

2022-11-09 221109-30938
==================
增加连供的开关阀测试。修改GpioTestPopWindow.java

2022-11-09 221109-30937
==================
取消30935.1及30936的修改，恢复原样，增加ControlTabActivity.java类中的下列修改，
去掉类变量
	DataTransferThread mTempThread = DataTransferThread.getInstance(mContext);
的声明时初始化，因为此时初始化的话，mContext应该为null。而改为仅生命，初始化原来就在执行的时候做的
	DataTransferThread mTempThread;
这样，就不需要30935.1及30936的修改了，这两处都是因为前者在声明时初始化导致的mContext为空。

2022-11-09 221109-30936
==================
改在initDataaBuffer函数中注册的提示窗对话窗仍然死机，原因是mContext此时还为空，因此需要使用随函数的参数context才行

2022-11-09 221109-30935
==================
1. 解决黑屏问题，原因是新添加的Bagink的Level信息显示提示窗的打开操作放在了DataTransferThread构建函数里面，此时进行此操作引起异常。改在initDataaBuffer函数中执行。
2. 暂时将SmartCardManager的墨袋改为墨盒（CARD_TYPE_BULK = CARD_TYPE_BULKX;），！！！测试结束后需要恢复

2022-11-08 221109-30934
==================
(主要在11-8修改，11-9完成，日期标签为11-8）
1. Bagink版，加墨的阈值采用Rfid0的特征值第6个数值，主要修改的是RfidScheduler.java类，在对于Bagink的修改内容当中，没有加日期注释标签。
2. 增加显示Level值的对话窗。主要修改的是DataTransferThread.java类，有日期注释标签，和RfidScheduler.java类，没有加日期注释标签。
2.  开始打印时，如果Rfid0的特征值第6个值小于300，则报警。

2022-11-05 221105-30933
==================
1. 修改完hp22mm的测试页面，这个页面在10-15日做了部分修改后停止作业，再次重开。涉及GpioTestPopWindow.java类，Hp22mm.java类，以及hp22mm.c
2. 增加判断hp22mm版本img的功能，如果是22mm类型的img，则生成SmartCardManager和SmartCardScheduler，这个是暂时的举措，待库调通以后们需要有一个Hp22mmManager和Hp22mmScheduler来替代。
3. 增加根据img的种类，如果是M5, M7, M9, 或者是基于M9的BAGINK，22MM，则不显示电池信息区的信息

2022-11-02 221102-30932
==================
根据硬件的现状，调整LEVEL与RFID头的对应关系。
level  
头1 选  （RFID头1）
头2 选  （RFID头4）
头3 选  （RFID头2）
头4 选  （RFID头3）

2022-11-02 221102-30931
==================
BAGINK测试开阀改为打开后10ms拉低

2022-11-02 221102-30930
==================
追加BAGINK功能的测试页面，主要修改的时GpioTestPopWindow.java类

2022-11-01 221101-30929
==================
经确认，BAGINK的LEVEL的访问，不是按着SC的方法通过切换PEN来切换LEVEL的，而是通过切换RFID的同时，也切换了LEVEL的通道（I2C的地址不变），因此，原来直接调用SC的LEVEL访问的方法不能用，需要修改，具体修改如下：
(1) 在SmartCard的so当中追加两个API，initLevelDirect和readLevelDirect，这两个API的实现与原有的initComponent和readLevel一样，只是不主动切换PEN，以免切换PEN而倒置进入错误路径，GPIO路径的切换在apk中实施
(2) 在RfidScheduler.java类当中，修改mLevelIndexs数组，从参照SmartCard的PENn改为RFID_CARDn，根据这个数组，在初始化时切换LEVEL，达到逐个启动LEVEL的目的
(3) 注意，initLevelDirect和readLevelDirect这两个api在调用之前，需要执行SC的init，这个init过程在SmartCard.exist调用中被执行了，因此可以在RfidScheduler当中放心调用，但是一定注意，要在这之前执行exist调用

2022-10-29 221029-30928
==================
追加一个BAGINK的img，并且同时修改了apk当中InkScheduler.java类当中的相应功能

2022-10-25 221025-30927
==================
快速分组的文件名修改为"GROUP#"

2022-10-25 221025-30926
==================
追加一个“快速分组”的信息类型，该类型以"Group-"为文件名开头，信息中的每个超文本作为一个独立的信息保存在母信息的目录当中，并且所有的子信息作为一个群组管理，该子群组的信息也保存到母信息的目录当中。
打印的时候，不打印母信息，而是每次触发打印一个子信息。
修改设计的类有：MessageTask.java（信息的生成与管理）， EditTabSmallActivity.java（信息的保存），ControlTabActivity（信息的打印）

2022-10-24 221024-30925
==================
1. 替换10.ttf字体
2. 在开机后设置参数以后，如果不是盖章机，发送FpgaGpioOperation.uninit()，使设备停止于停止状态，目的是尝试解决开机后立即清洗的话，清洗不能启动的问题。

2022-10-19 221019-30924
==================
2022-10-17 - 2022-10-19 修改的内容如下：
1. DataTask.java类中增加一个expendColumn函数，用来支持64SLANT头的上下半段的倾斜处理，具体倾斜处理的要求是
	a. 增加64Slant喷头类型。 （此类型暂时理解为两个32 点喷头，1-31点和33-64点）。    
	b. 原有 喷头一  镜像/倒置/偏移，  控制1 头。    二头的控制二头。 
 	c. 增加 Slant2 参数。 用于控制第二喷头倾斜。（原有SLANT  用于控制第一个32 点喷头倾斜）
	d. 增加 “调整2”“/”ADJ2”参数，  用于调整喷头2的宽度， 规则：默认值是0， 设为n, 则展宽为 32+n,  
2. 参数的数量扩容，原有64个参数已经用满，扩充到96个，具体涉及的类有：
	SystemConfigFile.java和SettingsListAdapter.java类
前者是参数的管理模块，后者是参数的编辑模块
同时在各语言版本的string.xml中追加相应参数的内容。
3. 追加两个参数，Slant2（参数65）和调整2（参数66），DataTask.java类的rebuildBuffer函数中会在喷头类型为64SLANT时，参照两个参数的设置进行倾斜的特殊处理。同时修改各语言版本的string.xml文件内容。
4. 追加一个64SLANT喷头类型。该喷头类型的要求如上条a项目，特点是分成上下两端进行镜像/倒置/偏移处理，并且上下两段可以分别进行倾斜处理。为此，
   4-1 在PrinterNozzle.java类中追加该喷头类型，具体内容参照64SN进行设置 
   4-2 对于源代码中多处判断喷头类型的地方进行相应修改，由于修改的地方较多，具体参照代码
   4-3 在array.xml中追加喷头类型名称

2022-10-10 221010-30923
==================
在obj_info_barcode.xml画面的底部增加超文本的说明文本信息，与超文本录入页面一致。系30922版修改遗漏

2022-10-8 221008-30922
==================
追加数据源：变量/Auto-data。在SystemConfigFile.java类中追加下列行：
	public static final int DATA_SOURCE_AUTO_DATA = 24;
该数据源的意图是，使得动态条码使用变量本身保存的信息作为生成条码的依据，而不使用桶里的内容，也不影响桶里的内容，此时，本信息的内容主要为超文本。

（原来的动态条码的实现逻辑是：打开文件后，使用桶中保存的内容作为当前内容使用，除非收到串口、网络等外部数据进行修改。
p.s.
获取外部数据需要设置相应的数据源为串口或者网络的相应种类，收到的外部数据会在此数据源被选择后，同时修改桶和变量的值，如果打印作业没有被启动，只影响桶的值）

2022-9-29 220929-30921
==================
修改DataTransferThread.java类中，getInkThreshold函数中计算rate的算法，以前是只根据INDEX_DOT_SIZE计算，修改为取INDEX_DOT_SIZE与INDEX_STR中的最大值进行计算。
细节代码如下：
//	rate = Math.max(0.5f, (1.0f * config.getParam(SystemConfigFile.INDEX_DOT_SIZE)+640)/1600);
	rate = Math.max(0.5f, (1.0f * Math.max(config.getParam(SystemConfigFile.INDEX_STR), config.getParam(SystemConfigFile.INDEX_DOT_SIZE))+640)/1600);

2022-9-15 220915-30920
==================
在SmartCardManager.java类中，单独设置一个错误显示消息，用来显示错误信息，并且禁止后续信息显示替换掉该内容，错误信息被后续信息覆盖。
追加一下内容，及代码中其他部分相应的修改
    private static final int MSG_SHOW_ACCESS_ERROR      = 104;
    private boolean mErrorShowing                       = false;

2022-9-15 220915-30919
==================
(1) initComponent函数中，对于adjustLocalInkValue函数的调用，原来传递的参数错误，没有起到调整的作用
(2) 为adjustLocalInkValue函数和getMaxVolume函数添加log

2022-9-8 220908-30918
==================
将SmartCard.downLocal的调用提取出来，并且增加如果失败，尝试3次，3次都失败，尝试初始化。
（涉及Smart Card Manager.java类）

2022-9-7 220907-30917
==================
解决动态二维码通过串口设置具体内容（超过6位）时，后面的内容被切割掉的问题。问题的原因是，由于220616-30880版本的修改动态二维码的内容改为参照内部的保存桶里面的内容，
导致编辑窗口对内容的设置失效，结果是动态二维码的位数被固定为了6位。并且，在实时生成打印缓冲区的时候，动态二维码的宽度会根据具体内容的字数，重新计算宽度，因此，如果，
实际的内容的字数大于6，就会导致二维码的宽度变宽，从而挤压后面的内容的空间，导致后面的内容被切割掉。修改方法是：
1. 在编辑页面，根据对话窗输入的内容的字数，计算动态二维码的宽度（涉及ObjectInfoDialog.java的mOk的onClickListenner函数和BarcodeObject.java的setContent函数和calWidth函数）
2. 其他的对动态二维码的内容的修改，不会导致重新计算宽度（涉及BarcodeObject.java的setContent函数）

2022-9-5 220905-30916
==================
空号，仅仅为了Git上下传实验。

2022-9-1 220901-30915
==================
更换打字机清洗文件。purge/purge4big.bin

2022-9-1 220901-30914
==================
追加一个启动客户APK的功能，根据参数64的设置，如果为0则不启动，如果为1则如果客户apk存在的话启动。客户APK的路径名为
/system/app/UserAPK.apk
添加在了MainActivity类的DeviceInfosr函数中

2022-9-1 220901-30913
==================
对于64SN头的变形处理，做一下完善。  每16点看作一个喷头。 

1. 支持左右  （按64 bit 一列反过来）
2. 支持mirror  (0-15, 16-31. 32-47,48-63, 每16点一个头 )， 每头独立掉头
3. 支持 “倒置”， 也是每头16点， 独立倒置，  但是注意 ，  1和2 头都倒置， 就是0-31一起倒置，    3-4 头也是 
但是如果 1-4 都设倒置， 是0-63 点一起倒置。 
4.  头1-4 独立控制 ，  设24 偏移一列， 48 偏移两列 以此类推。

根据分析，在DataTask.java类中的rebuildBuffer函数中，对于大字机，已经设置了
	heads = 4;
	offsetDiv = 24;
即，按着4个头进行处理（偏移基数24，详细内容看代码），
因此，仅需要在isNeedRebuild函数中，经过移花接木的方式，使得大字机的时候，不是只检查一个头的变形设置，而是按着4个头的设置信息检查就可以了。
因此，对isNeedRebuild函数的头数的取得做了修改，如果是打字机，则头数设为4。

同时，需要在PrinterNozzle.java类中，将64SN的变形属性放开如下，否则不会有动作：
                reverseEnable = true;
                shiftEnable = true;
                mirrorEnable = true;
                rotateAble = true;
并且，BufferRebuilder.java类中的reverse函数处理似乎有问题，限定为每列4个字节，修改为了每列的字节数必须为4的倍数。

2022-8-31 220831-30912
==================
对于打印前更换了墨盒的情况，禁止打印，恢复原来的SN和KEY值，并且在主画面显示不要带电更换墨盒的信息。
修改模块（RFIDManager.java, ControlTabActivity.java, strings.xmls）

2022-8-25 220825-30911
==================
追加参数62，喷头加热/Warming。并且在S23的Bit1下发给FPGA。

2022-8-19 220819-30910
==================
取消30909的修改，改为：修改96DN头的操作。mirror打开，否则打印方向调整会不起作用，shift关闭，否则会导致标准的便宜处理和96DN的特殊处理叠加，出现错位的问题

2022-8-19 220819-30909
==================
修改96DN打印头的后期变换策略，与16点打印头一致（原策略是不进行任何变形操作）。

2022-8-19 220819-30908
==================
1. 2022-8-2追加正在写墨袋的排斥锁，以防止正在写的时候被停止，导致写的信息出错（国外出现了）
2. 追加2021-8-16 追加96DN头时的修改遗漏，导致编辑96DN信息的时候，指定16x12无效，被改成7x6

2022-7-20 220720-30907
==================
恢复到正式的CARD_TYPE_BULK1状态

2022-7-20 220720-30906
==================
修改为一次减1%，再次减1%需要重新启动减1操作，直到减到90%后不再减少了。仍然还是在CARD_TYPE_BULKX下运行，确认动作后再修改回来。

2022-7-20 220720-30905
==================
修改了30904版本的BUG

2022-7-20 220720-30904
==================
修改了30903版本，原来全部基于对话窗实现功能调度，统一到原来的基于消息的运行环境

2022-7-20 220720-30903
==================
30902版本的基础上，修改减数逻辑，启动减数功能后，直接减到最大数的90%

2022-7-20 220720-30902
==================
30901的临时版本，用CARD_TYPE_BULKX代替CARD_TYPE_BULK1使用

2022-7-20 220720-30901
==================
在测试页面追加一个墨袋减1的操作按钮。设计修改的是GpioTestPopWindow类盒SmartCardManager类

2022-7-14 220714-30900
==================
将NOZZLE_TYPE_96DN头类型的所有变换属性都设为false。
                shiftEnable = false;		// 偏移
                mirrorEnable = false;		// 镜像
                reverseEnable = false;	// 反转
                rotateAble = false;		// slant

2022-7-12 220712-30899
==================
1.  原来没slant，  现在也不用
2.  0-15， ，  32-47 ， 64-79， 为第一组，16-31，  48-63， 80-95， 为第二组
3.  第一组根据喷头一偏移，后移相应列数
4.  第二组根据喷头二偏移， 后移相应列数

2022-7-8 220708-30898
==================
在测试读取Level的实验中，取消读错数据后的重启机制，改为每正常读4次后，第5次是在睡眠状态下读取，依次重复100次。

2022-7-8 220708-30897
==================
重复起振的方法从睡眠-等一会儿-苏醒，改为重启设备-等一会儿-苏醒

2022-7-7 220707-30896
==================
修改SmartCardManager类中testLevel函数里的log输出，与屏幕的轮次对应显示

2022-7-7 220707-30895
==================
修改libsmartcard.so驱动，当中testLevel失败时重新起振的逻辑，判断是否位0x0FFFFFFF。

2022-7-5 220705-30894
==================
1. 修改libsmart card.so驱动，无论readLevel还是testLevel，都先读数，如果读到的数为FF，则重启Level一次
2. readLevel的时候，如果读到了FF，则说明so肯定尝试重启一次Level了，beep警报一声

2022-7-5 220705-30893
==================
将上个版本的休息循环10000000语句修改为1000000（去掉一个0）。

2022-7-5 220705-30892
==================
1. 取消增加的几个设置参数
2. 将上个版本的休息50ms改为循环10000000语句消耗时间。

2022-7-5 220705-30891
==================
设置睡眠状态后休息50ms，脱离睡眠状态后仍然睡50ms

2022-7-5 220705-30890
==================
修改libsmart card.so驱动，在testLevel函数中：
1. 设置睡眠状态后休息100ms
2. 增加几个设置参数。Set Full Current Mode, RP Override Enable, Disable Automatic Amplitude Correction, Set High Current Drive

2022-7-5 220705-30889
==================
修改30888的BUG

2022-7-5 220705-30888
==================
修改libsmart card.so驱动，取消30887的修改内容，增加一个testLevel的接口，该接口实现与readLevel一样的功能，只是在读取Level值之前，重启Level设备（先进入睡眠，5ms后取消睡眠）。在SmartCard当中追加testLevel接口。在SmartCardManager类中的startLevelTest中，取消readLevel的调用，改为调用testLevel。

2022-7-4 220704-30887
==================
修改libsmart card.so驱动，在读DeviceID的时候，同时重启设备（即取消睡眠模式）

2022-6-30 220630-30886
==================
修改30880版本对动态条码桶修改的纰漏。当桶中还没有设置条码的时候，不能返回空，返回空会导致生成的条码位图宽度为0，导致异常。修改为桶中没有内容时，返回一个缺省值123456，跟BarcodeObject的处理策略一致。

2022-6-29 220629-30885
==================
修改DataTransferThread接收到串口数据时的处理，有部分处理会一边修改DT的内容，一边设置
	mNeedUpdate = true
导致，生成打印缓冲区的代码可能会立即执行，而生成修改途中的打印内容。有一部分的设置是正确的，即：
设置一个中间变量，用来在修改具体的某个DT时，记载有DT已经被修改。
	boolean needUpdate = false;
带所有DT都被遍历之后，再修改
	mNeedUpdate = needUpdate 
以避免不必要的提前动作

2022-6-20 220620-30884
==================
修改网络停止打印时预览画面不恢复的问题。将恢复标准静态预览画面的执行部分，从StopPrint控件响应处理部分移到MESSAGE_PRINT_STOP事件处理部分执行，这样就可以兼顾到网络，串口等有程序控制停止打印时执行此操作，而不至于只是点按按键时才做此操作。

30883(空号)

2022-6-18 220618-30882
==================
对210728-30684的实时预览功能进行优化，具体内容是：点击预览显示区一次开启实时预览，再次点击关闭实时预览。原来的实现也是这么实现的初衷，但是有BUG，没有能够做到。
至此，实时预览的功能总结：
1. 显示将会实际打印出来的内容，即对于用户来说所见即所得
2. 在待机状态，点击无效；打印状态下，缺省显示静态预览信息；每次点击后在预览显示区切换显示静态预览和实时预览图片

2022-6-17 220617-30881
==================
在停止状态下接收到远端数据时，添加提示显示对话窗

2022-6-16 220616-30880
==================
2022-6-13修改，2022-6-15动作确认
1. 增加不挥发存储保存10个DT桶内容
2. 开机时读取不挥发存储保存的10个DT桶的内容，作为后续赋值给DT变量的值
3. 当数据源为DATA_SOURCE_LAN, DATA_SOURCE_LAN_FAST, DATA_PC_COMMAND时，可以接收远端传送来的数据，数据的格式为10个DT加1个条码，用逗号分开的格式（串口协议2的格式）
4. 支持网络命令600和650。在打印状态下，600命令根据信息中DT变量的出现顺序按序设置10个DT桶的内容，并且将接收到的内容根据DT变量的Index，设置到相应的桶当中；650命令则按序将接收到的DT值依次赋值给各个桶。当不在打印状态的情况下，无论600命令还是650命令，均按序将接收到的DT值依次赋值给各个桶（因为不存在待打印信息，无法获取DT变量）。各个设置到桶中的远端数据，同时保存到不挥发存储中，待下次使用。
5. 忽略掉远端数据的条码信息(第11个数据)，待以后确定内容后再添加。
6. 其他串口协议修改DT桶中内容的操作（串口协议2以外的一些串口协议会修改DT桶），也会同时被保存到不挥发存储当中
7. 2022-6-16追加对条码信息的支持(时间标签仍然为2022-6-15)

2022-6-11 220611-30879
==================
增加打印缓冲区后部空白清空的功能。在DataTask类的getPrinterBuffer函数生成变量bin后，未进行各种变形之前实施。

2022-6-10 220610-30878
==================
因为isTlkReady函数中，即判断是否有1.tlk也判断是否有1.bin，因此网络开始打印(CMD_PRINT, 100)单个信息能够成功，但是群组会失败，因为群组当中没有1.bin。修改后值判断1.tlk的有无

2022-6-9 220609-30877
==================
取消接收到CMD_MAKE_TLK命令(700)后，向PC机发送与apk同语言版本的返回信息(start building tlk...)，统一只发送英文版本

2022-6-8 220608-30876
==================
修改PCCommandHandler类中的MakeTlk函数，从ControlTabActivity移植过来的时候，从使用成员变量myHandler改为临时生成Handler的问题，因为线程当中不能创建Handler。本来可以通过比较合理的方式实现这套机制，但是由于原本的reCreate函数使用了Handler作为参数返回处理结果，这种返回结果的方式不太好，可以通过返回值，或者Interface的方式也可以，直接用Handler的方式太不合理。

2022-6-7 220607-30875
==================
更新4，7，12，14号字体。
1. 4(7X5)完善俄文大小写 -0814.TFF
2. 7 完善俄文大小写220606 -1 .TTF
3. 12 完善俄文大小写 220606-1.TTF
4. 14 (完善俄文大小写 0331.TTF

2022-6-7 220607-30874
==================
追加忘记添加的当参数41为连续打印(65535)的时候，FPGA参数的修改。
S4 -> S6; S9 -> S8

2022-6-6 220606-30873
==================
修改参数41的有效值范围（params.xml）

2022-6-6 220606-30872
==================
追加连续打印功能（包括apk和img）

2022-6-1 220601-30871
==================
增加一个LAN协议（PC串口同）。新协议为
    public static final String CMD_SET_REMOTE1 = "650";
    public static final String CMD_SET_REMOTE1_S = "Dynamic1";
具体功能是，有远端接收到下列内容：
<DT0><DT1>...<DT9><BARCODE>
与原有的CMD_SET_REMOTE和CMD_SET_REMOTE_S将DT0-DT9顺次设置给信息中的DT不同，而是设置给全局的10个DT桶中，用来设置给所有的信息当中的相应DTIndex的DT。换言之，不是将DT0-DT9顺次设置给信息中的DT，而是设置给信息中DT所对应的DTIndex当中。
如：接收到111,222,333,,,,,,,,
信息中包含有三个DT，分别为DT0(DTIndex=1),DT1(DTIndex=0)，DT2(DTIndex=1)
那么，使用原来的CMD_SET_REMOTE协议会得到
DT0=111，DT1=222，DT2=333
如果使用CMD_SET_REMOTE1，则会得到
DT0=111，DT1=222，DT2=111

2022-5-31 220531-30870
==================
P-5的时候向FPGA的PG1和PG2下发11，3ms后再下发00

2022-5-31 220531-30869
==================
修改params.xml当中对于输入命令（INDEX_IPURT_PROC ）参数的有效值及范围的有效区间，配合增加PROTO_5要将max相应的设置为4

2022-5-30 220530-30868
==================
1. 30866版本修改的输入命令（INDEX_IPURT_PROC ），综合操作改回到原来的PROTO_4，清零操作改到PROTO_5，以保持与原版本的兼容
2. 30865版本修改的32x2后移改为2列

2022-5-30 220530-30867
==================
增加参数59，Width Ratio /宽度调节，新的S14 =老的S14 * w/100（w<=10时按100处理）

2022-5-28 220528-30866
==================
1. PCCommandHandler类中，在设置SetRemote中追加PC命令的判断，
   当数据源定义为PC命令的时候，通过串口传递WIFI的命令。但是，由于PC命令占用了数据源的LAN和LAN_FAST的位置，这里协议是冲突的，因此视作LAN和LAN_FAST打开，但是LAN的动作能够全部实现，LAN_FAST由于有多余的打印流程控制，不会动作
2. 修改外部输入命令
   INDEX_IPURT_PROC 		= 56
   追加一个PI11的清零操作，将原综合操作的PROTO_4改为PROTO_5，清零操作使用PROTO_4

2022-5-28 220528-30865
==================
修改为下32bit后移3列

2022-5-28 220528-30864
==================
修改32x2类型生成打印缓冲区时的bug

2022-5-27 220527-30863
==================
追加32x2类型的打印头。具体内容如下：
新增32x2喷头类型， 实际就是64点双列的， 
只不过打印buffer 要转换如上图 
奇数bit,进上32, 偶数bit 进 下32 bit 
然后 上32 bit , 后移4 列。 
大概原理如此， 后面要实验调整

*【额外说明】 从该版本以后，均包含30861及30862版本的修改内容，但开机升级代码还没有修改到新的升级函数（silentUpgrade2），版本号也没有进行修改，需要后续确认后再行修改。对于升级程序的测试可以在该版本及以后的版本中进行测试

2022-5-26 220526-30862
==================
在PackageInstaller类中，追加USB的鉴权操作，当新的apk与当前apk都为新版apk的时候，如果当前apk的feature值与新版apk的feature值不相同时，检查USB盘当中的鉴权信息（该信息为文件名为1-1到1-100个字符串的MD5值生成的100个文件文件名，进行了乱序排列，其中第79个文件为要确认的文件名，这个文件的位置固定在第79位）

2022-5-24 220524-30861
==================
1. 修改设置->时钟对话窗格式，使得输入框进入一个横排，减少行数，以便弹出软键盘后，所有元素均可见
2. 对话窗中追加Upgrade按键，实现手动启动升级操作
3. 修改升级策略
    当前的5位数版本号称为旧版，9位数版本号称为新版。
	1. 旧版本 -> 新版本升级，无条件可实现；
	2. 新版本 -> 新版本，相同特征号间可升级；
	3. 新版本 -> 新版本，不同特征号间不可升级；
	4. 新版本 -> 旧版本，不可升级
4. 在sdcard/system下增加feature.xml文件，用来保存本机本地特征值。操作规范为：
	1. 开机后，检查本机是否有该文件，如果没有，则生成该文件，保存新版apk版本号后4位；旧版apk忽略
	2. 开始打印前监测该文件保存的特征码与apk版本号的特征码的一致性，如果不一致，则可以认为该apk为不合法推送，显示错误信息后，不执行打印

2022-5-21 220521-30860
==================
修改几处BUG

2022-5-21 220521-30859
==================
测试功能修改几处BUG

2022-5-21 220521-30858
==================
追加全部的墨盒（无论插与没差，实际上库是通过MESSAGE_TYPE_25_4是否选择设置是双头还是单头的）

2022-5-21 220521-30857
==================
完善了SC及Level的测试画面功能

2022-5-20 220520-30856
==================
修改%的显示方法

2022-5-20 220520-30855
==================
修改libsmartcard.so当中，获取DeviceID和ManufactureID的数据类型为有符号，否则无法在访问失败时返回(-1)，实际返回的时65535。

2022-5-20 220520-30854
==================
在SmartCardManager中追加ID测试功能中追加了几条LOG

2022-5-20 220520-30853
==================
1. 大幅修改测试页的布局和功能。由专为测试IN/OUT管脚扩充为多用途测试。当前增加了ID的测试，后续继续添加SC和LEVEL的测试
   (gpio_test_pop.xml及GpioTestPopWindow均做了大幅度的修改)
2. 在SmartCardManager中追加ID测试功能

2022-5-18 220518-30852
==================
修改通过接收到的报文合成信息编号时的BUG

2022-5-18 220518-30851
==================
修改当报文字节数不正确时（包括校验码当中包含特殊字符而没有转义时错误将必要字段删除的错误）报错，避免崩溃

2022-5-18 220518-30850
==================
修改串口协议1的启动打印特定编号的信息命令(21)未返回串口信息的问题

2022-5-16 220516-30849
==================
1. 追加串口2的新功能：启动打印特定编号的信息(21)
2. 追加串口协议“串口协议二无线”。用来支持再CH341上实现串口协议2

2022-5-13 220513-30848
==================
在SmartCard的库中，追加读取Level的ManufactureID和DeviceID的api，目的是定期读取，监测线路的稳定性。
在SmartCardManager类中，每个墨盒类中追加一个DeviceID的变量，与读取墨盒的Level值通知读取该变量。如果该变量的值发生变化或失败，则赋值-1（以后维持该值不变，以便于界面确认错误的发生），否则赋值读取的正确信息，与Level的显示对话窗同时显示。显示位置为Level - <序号> - <DeviceID值>（21,808 or 12,373）

2022-5-12 220512-30847
==================
修改读写逻辑，如果读失败，超时返回，则最多等待5次，每次等待100ms，作为一个尝试循环。如果失败，再次发送写命令，后重新开始读尝试循环，最多3次。上述尝试失败以后，向应用层报错

2022-5-10 220510-30846
==================
(是否有效，试试看)取消直接在线程当中使用final Bitmap bmp，改为使用成员变量。可能是因为这个参数传递导致时间长了bitmap被回收

2022-5-9 220509-30845
==================
在IInkScheduler的create函数中，将SmartCard.exist调用的异常处理定义为UnsatisfiedLinkError e，而不用Exception，并且增加错误输出，否则catch不到（原因不明）。这个地方为30844版本的修改遗漏。

2022-5-9 220509-30844
==================
1. 在refreshInk函数里面增加输出img版本号的功能
2. 在InkManagerFactory的getManager函数中，将SmartCard.exist调用的异常处理定义为UnsatisfiedLinkError e，而不用Exception，并且增加错误输出，否则catch不到（原因不明）

2022-5-6 220506-30843
==================
调整回30840版本前的控制的头组。即，参数11控制13579头偏移，参数12控制24680头偏移

2022-5-5 220505-30842
==================
修改30841版本BUG，DIRECTION_REVERSE目标列计算有误（newCols作为最后一列），导致死机，newCols - 1作为最后一列为宜。

2022-5-5 220505-30841
==================
1. 修改30840，追加MB打印缓冲区的左右方向调整
2. 增加点击设置画面版本信息条部分关闭软键盘

2022-5-5 220505-30840
==================
调换参数11和参数12所控制的头组

2022-5-5 220505-30839
==================
增加25.4x10的偏移功能。当前的实现方法是在getPrintBuffer函数中，根据当前打印头的种类，如果是25.4x10，则强制根据参数11或者参数12的设置进行3200点高度的打印缓冲区的13579或者24680的整体偏移。如果是其他类型的打印头，沿用从前的rebuildBuffer函数

2022-4-29 220429-30838
==================
新追加的25.4x10喷头头数为10的话，会在打印的时候溢出，暂时改为1

2022-4-29 220429-30837
==================
追加25.4x10喷头类型（部分追加），等待看后续效果，参照查找关键字(_1_INCH)

2022-4-25 220425-30836
==================
220408-30817版本取消了QR_R.csv到了文件末尾自动停止打印的操作。但是DataTransferThread类中的PrintTask里面判断到了文件末尾后没有同时取消跳出无线循环的break；这样在旧的img时，会导致停止打印，设置了QRLast参数为0以后，再次开始打印时出现一次空打印

2022-4-24 220424-30835
==================
修改重新开始打印操作过于迅速导致卡死的问题。原始是RFIDAsyncTask类中的run函数，在read读取RFID反馈信息的时候，超时没有读到数据而导致返回值为null，后续导致空指针异常发生

2022-4-24 220424-30834
==================
1. 动态文本的编辑框显示颜色调整为蓝色
2. 重新设置QRLast值后。立即生效

2022-4-23 220423-30833
==================
动态条码的显示颜色（编辑窗和预览窗）调整为蓝色

2022-4-22 220422-30832
==================
修改俄文string.xml

2022-4-22 220422-30831
==================
动态条码在编辑的时候可以输入内容，以后，改内容的宽度将成为该动态条码的宽度，新的内容将被框定在该宽度内

2022-4-21 220421-30830
==================
标准SC卡apk。
1. 使用真的墨袋
2. 墨盒代替墨袋时，最大容量也不乘3

2022-4-21 220421-30829
==================
修改SmartCardManager类中isValid函数中，重新初始化的逻辑，没有初始化过的不尝试

2022-4-20 220420-30828
==================
修改30827版本bug

2022-4-20 220420-30827
==================
SmartCardManager，选择BULK1时如果插入墨盒，或者选择BULKX时如果插入墨袋，均报错。修改libsmartcard.so，版本号升级为1.0.376

2022-4-20 220420-30826
==================
SmartCardManager，用墨盒替代墨袋的临时版本

2022-4-19 220419-30825
==================
SmartCardManager，当检测到OIB时，显示提示Toast

2022-4-19 220419-30824
==================
<空号>

2022-4-18 220418-30823
==================
SmartCardManager类中做一下修改。
1. 打开OIB_CHECK开关，今后正常情况下此项目设置为打开状态
2. 追加一个mOIB成员变量，用来记忆各卡区分于一般失效（mValid）的OIB失效的种类
3. 将30820版本当中的第二方案恢复，与第一方案共存，次数修改为5次
4. 修改做第一方案修改后，初始化完成之前getLocalInk函数调用，为保证初始化失败也支持打印的需求对锁值设置的虚假值（最大值的二分之一）。具体做法是，在初始化成功是，将锁值强制设置为-1，重新从卡中读取

2022-4-16 220416-30822
==================
替换掉临时清空墨袋锁值版本的so，这个so的目的是临时性清空锁值以满的墨袋的值，需要恢复到正常版本的值

2022-4-16 220416-30821
==================
修改SmartCardManager类当中的downLocal函数，将墨盒与墨袋的减锁操作分离

2022-4-14 220414-30820
==================
【第一方案】
临时修改Smartcard的功能。如果PEN初始化失败，则暂时不禁止打印。处理方法是，修改了SmartCardManager类中的3处，当PEN初始化失败以后，视作初始化成功，但是墨量按全量的1半处理。并且墨位不会被检测
【第二方案】
取消第一方案后，在initComponent函数中，增加了如果失败尝试3次的逻辑。当前代码停留在第一方案上

2022-4-12 220412-30819
==================
在调用SmartCard.exist函数的地方，加上try外套，以免如果使用的是旧的smartcard库时，jni没有该函数导致死机崩溃

2022-4-8 220408-30818
==================
更改 purge4big.bin , ， 两列喷嘴喷头，双列同时清洗

2022-4-8 220408-30817
==================
当QR_R.csv文件全部打印完成时，取消停止打印，因为取消太快的话，打印内容可能被切掉，改为报警

2022-4-7 220407-30816
==================
修改串口11中后面的0也被修改为空格的问题

2022-4-7 220407-30815
==================
打开长清洗接收后的imglog输出

2022-4-5 220405-30814
==================
追加串口协议11(341串口)
【说明】
// 走CH341串口（ttyUSB0）
// 具体要求参照《341串口协议.doc》文档
// 数据格式为
// 	帧头：0x1B, 0x53
// 	功能码：0x31, 0x31
// 	内容：0x30, 0x30, 0x31, 0x38, 0x2E, 0x32, 0x6B, 0x67
// 	校验位：0xCB
// 	帧尾：0x0D, 0x0A,
//（全文实力）：0x1B, 0x53, 0x31, 0x31, 0x30, 0x30, 0x31, 0x38, 0x2E, 0x32, 0x6B, 0x67, 0xCB, 0x0D, 0x0A

2022-4-4 220404-30813
==================
32DN， 也要改一下，  
选择32DN 喷头时：、
1 . Slant =0 , 不变
2. Slant>8, 维持上周做的逻辑不变
3. 1<=slant<=8.    调整逻辑：
a:  32 bit 每列 变为 64 bit/列。 （规则和=0 相同）
b:  按slant 设置，  和=0 做相同偏移， 不过=0 是固定移动4 列， 这个是按slant设置，值移动1-8 列

2022-4-2 220402-30812
==================
purge4big.bin采用19KB的版本。宽度大概是4608列

2022-4-2 220402-30811
==================
1. 32DN从插入7列改为插入3列
2. purge4big.bin采用减半的版本

2022-4-1 220401-30810
==================
大字机改为1倍（试验），HP还是恢复到原来的36倍

2022-4-1 220401-30809
==================
修改清洗数据区没有按着不同数据的倍率进行大小调整的问题

2022-4-1 220401-30808
==================
大字机改为4倍（试验），HP还是恢复到原来的36倍

2022-4-1 220401-30807
==================
将2022-3-18 220318-30795版本打开的36倍恢复到最初的12倍

2022-4-1 220401-30806
==================
1. 取消生成清洗缓冲区时取消插值（preparePurgeBuffer函数）
2. 修改动态生成动态文本变量的打印缓冲区时的算法。包括BinInfo类中相应的修改。具体内容为:
   2-1 	public BinInfo(Context ctx, Bitmap bmp, int type, ExtendStat extend) {
       追加type参数
   2-2 参考type参数，这个参数对后续的处理是必要的
		if (type <=0 || type > 4) {
			mType = 1;
		} else {
			mType = type;
		}
   2-3 展开图片也要传递头数参数
	m.extract(bmp, mType, false);
   2-4 修改DataTask类中，动态生成动态文本打印缓冲区的代码，追加根据头数做的放大倍率调整

2022-4-1 220401-30805
==================
替换标准14字体，修改了俄文的大小写

2022-3-30 220330-30804
==================
2022-3-30 220330-30803 - 取消
==================
修改32DN的双列的逻辑
【要求】感觉是   
32中 奇数bit  ,
 放在64 bit 的1-16.  
16 bit 0
偶数bit， 放在32-48. 
16 bit 0

插7列空  64 bit 0.

偏移的时候， 直接把下面32 bit, 后移 slant 列

2022-3-29 220329-30802
==================
追加32DN的双列打印功能。具体内容如下：
【要求】
1.  每16 bit 插16bit 0. (每列32 bit 变为64 bit)
2.  每列插7列0 （64bit x7 的0）
3. 偶数bit 后移slant 列
【理解】
//  1.  每16 bit 插16bit 0. (每列32 bit 变为64 bit)
//    示例：
//      1（代表4bit位）1
//      1            1
//      1            1
//      1            1
//      2            0
//      2            0
//      2            0
//      2            0
// (一个32点的完整列)  2
//                   2
//                   2
//                   2
//                   0
//                   0
//                   0
//                   0
//           (变为一个64点的插了空的列）
//  2.  每列插7列0 （64bit x7 的0）
//      1                      1
//      1                      1
//      1                      1
//      1                      1
//      0                      0
//      0                      0
//      0                      0
//      0  (中间插入7列64位的0)  0
//      2                      2
//      2                      2
//      2                      2
//      2                      2
//      0                      0
//      0                      0
//      0                      0
//      0                      0
//        (就是把相邻两列的插了空的列拉开，最终结果是原数据被插空后，将空间拉大16倍）
//  3.  偶数bit 后移slant 列

2022-3-23 220323-30801
==================
1. 修改俄语41.Times的文字，客户说应该是Серийная печать

2022-3-22 220322-30800
==================
1. 修改俄语41.Times的正确位置，源文件修改错地方了
2. 修改设置项目题目栏的宽度（250 -> 220)

2022-3-22 220322-30799
==================
修改设置画面的页面配置（setttings_frame_item.xml）

2022-3-22 220322-30798
==================
再次更新俄文string.xml资源文件

2022-3-22 220322-30797
==================
更新俄文string.xml资源文件

2022-3-21 220321-30796
==================
根据最新的管脚功能定义协议，对管脚功能进行了修改。
1. 协议内容
//     协议１：　禁止GPIO　
//     协议２：　　
//            0x01：是打印开始停止
//            其他禁止
//     协议３：
//            0x01：方向切换
//            其他禁止
//     协议４：
//            0x01：是打印“开始／停止”控制位。其中，打印开始停止实在apk里面处理的，方向控制是在img里面控制的
//            0x02：是计数器清零，包括RTC的数据和正在打印的数据
//            0x04：方向切换
//            0x08：空
//            0xF0段，即0x10 - 0xF0)为打印文件的文件名（数字形式，1-15）
2. 由于方向切换的方式再协议3和协议4当中使用的管脚不同，因此，对img做了修改。由原来在img当中读取管脚值，改为在apk通过ext_gpio读取以后，向fpga驱动下发是否进行反向生成缓冲区的标识设置。具体看FpgaGpioOperation的setMirror函数
3. 对apk的处理流程（ControlTabActivity中的mInPinReadTimer）做了大幅度的修改

2022-3-18 220318-30795
==================
1. 打开2022-1-3 220103-30762版本对purgebin的扩充的限制，恢复到放大36倍（DataTask类中的preparePurgeBuffer函数）
2. 根据img的版本，如果是以"GZJ"开头，则不进行倾斜处理（DataTask类中的preparePurgeBuffer函数）
3. 根据img的版本，如果是以"GZJ"开头，则按PURGE向FPGA下发数据（DataTransferThread类purge函数）
4. 在FpgaGpioOperation类中的writeData函数，追加
        if(type == FPGA_STATE_PURGE) {
            ExtGpio.setFpgaState(ExtGpio.FPGA_STATE_OUTPUT);
        }
    目的是当按PURGE下发数据（盖章机的时候），由于FPGA驱动无法自主将状态从SETTING(10)更改为OUTPUT(00)，从而无法有效激活清洗，因此需要apk主动下发该状态

2022-3-18 220318-30794
==================
在DataTransferThread的purge函数里面，根据img的版本，如果是老板新屏(关键字以"ON"开始），则按着原来的清洗模式(下发清洗数据），其他的按着修改后的按着正常打印模式下发数据

2022-3-17 220317-30793
==================
1. 暂时取消30791版本中下发参数后下发CLEAN的操作
2. 设置参数的S5和S7数值除2
            data[5] /= 2;
            data[7] /= 2;


2022-3-16 220316-30792
==================
SmartCardManager类中的墨袋暂时用墨盒(BULKX)代替

2022-3-12 220312-30791
==================
下发参数后，再次发送CLEAN命令。因为下发参数后，PG1和PG2的电平为01，需要调整到11（即CLEAN状态）

2022-3-4 220304-30790
==================
设置参数data[4] = 200（原来为100）

2022-3-1 220301-30789
==================
2022-1-4 220104-30763中对S5的修改（在FpgaGpioOperation类中，原值为100），修改为200。增加间隔时间，获取打印更长的效果

2022-3-1 220301-30789
==================
1. 开机时下发参数57参数（PI11镜像或者打印），这样才能够在初始即为镜像的时候，功能有效
2. 在IN5-8和Open按键切换信息文件的时候，增加printNext参数，是保证重新生成打印缓冲区

2022-2-16 220216-30788
==================
修改RFIDManager当中检查UUID的方法。在用户试图开始打印时会检查UUID，为了防止用户用户中途换卡，2021-11-9修改中将检查UUID的方法从读取UUID数据（实际是没有检查）修改为将当前的SN和读到的SN进行比较，这样就防止了用户中途换卡的问题。
但是，如果用户拔掉卡，会读取失败，导致UUID没有变化，而可以继续打印的问题。为此，2022-1-13版本增加了将SN清零的操作，这样就防止了中途拔卡的问题。
但是，如果用户在拔卡的状态下，再次尝试打印，由于已经清了一次零，再次清零后，两个比较会因为都是零而判断两个SN一致，从而错误的判断为卡没有问题。为了修改这个问题。做了如下修改：
1. 取消RFIDManager当中对SN的清零，因为这个清零仅对拔卡后第一次尝试有效
2. 在RFIDDevice中，parseAutosearch函数中，如果读取SN失败，则将mValid设为false。这样也可以防止继续执行（会带来什么其他问题还得确认）

2022-2-14 220214-30787
==================
在CounterObject中，setValue函数取消新值和旧值一致时直接返回的判断。理由是新旧值可能都是不合法的，但却相同。这样会导致不会做后续的调整。同时，如果value的新旧值虽然一致，但是mContent却不一致，也不会得到相应的调整。
（本次问题出在IN2做了清零后，RTC保存了0，但是由于IN2清零是在打印停止后进行的，mDataTask还存在，结果RTC又被修改为了start值的1，再次开始打印后，由于mValue值被setRange函数中调整为了1，但却没有对mContent进行调整，还是“0”，然后setValue的时候，由于是读取的RTC值，也是1，setValue就直接返回了，所以，getContent就变成了0，跟value不符的问题）
因为这个问题，同时在CounterObject的多处函数中，对mValue进行了调整，但是没有修改mContent的地方，增加了对mContent的修改

2022-2-14 220214-30786
==================
修改拉低IN2后，计数器跳过start值的问题。
比如，已经触发打印了计数器的值为5，实际上计数器值为6的打印任务已经下发到了驱动层，这时计数器清零为start的话，在触发之后，会打印6，在生成新的计数器值打印缓冲区时，会加上步长，这样刚才清零后的值（start），就会被加上步长，因此，start会被跳过。
修改方案是，在清零到start之后，如果正处于打印状态，取当前的打印任务，如果包含计数器，则这个计数器在清零前的最新值已经下发过，因此要重新根据清零后的值再次生成打印缓冲区，覆盖下发。因此，在上述条件满足的情况下，需要将mNeedUpdate设置为true，从而进行更新下发。

2022-2-14 220214-30785
==================
修改拉低IN2，计数器清零时死机的BUG，原因是循环变量选择混淆

2022-2-14 220214-30784
==================
修改管脚监测和控制功能。
原来的实现是，对于（仅对于）GPIO版本的img，检测PI11管脚的状态，如果管脚由高变低，则根据参数设置或开始打印，或启动打印缓冲区镜像。如果由低变高，则停止打印或者取消镜像功能。
修改为：
1. 当img为GPIO的时候，功能不变
2. 当img为SPI的时候，则
  2.1 启用IN1管脚（此时是PG0）作为对应于GPIO的PI11，功能完全一致
  2.2 启用IN2管脚（此时是PI5），当由高变低的时候，为计数器清零。包括RTC中的所有10个计数器清零，正在打印的任务中的计数器变量清为start值
  2.3 启用IN5-IN8管脚（此时是"PE8", "PE9", "PE10", "PE11"），代表一个数值（0-15），当数值为1-15时，选择文件名为1-15的任务作为当前任务（1.tlk-15.tlk），0时照旧
  2.4 当当前打印任务总的计数器变量到达end值时，将OUT4（此时是PH26）设高，并维持2秒

参考：IN管脚组和OUT管脚组
    String[] IN_PINS = new String[] {
            "PG0", "PI5", "PI6", "PE7", "PE8", "PE9", "PE10", "PE11"
    };

    String[] OUT_PINS = new String[] {
            "PI8", "PB11", "PG4", "PH26", "PH27", "PE4", "PE5", "Serial"
    };

老apk - 老img（gpio）：原来功能（PI11操作）
老apk - 老img（spi）：无功能
老apk - 新img（gpio）：同原来功能（PI11操作）
老apk - 新img（spi）：同原来功能（响应PG0操作）

新apk - 老img（gpio）：原来功能（PI11操作）
新apk - 老img（spi）：无功能
新apk - 新img（gpio）：同原来功能（PI11操作）
新apk - 新img（spi）：全部功能（IN1-IN8）

2022-1-25 220125-30783
==================
1. SmartCardManager类中，追击如果在初始化的时候PEN1，PEN2或者BULK没有插上，或者中途出现问题，在获取isValid的时候，如果不是true，则再次尝试初始化
2. 修改DataTranferThread类中印刷中清洗后恢复打印时下发参数的方法。由于原来没有needRestore变量的判断，会出现未开始打印时清洗崩溃的现象，
	FpgaGpioOperation.updateSettings(mContext, mDataTask.get(mIndex), FpgaGpioOperation.SETTING_TYPE_NORMAL);
为解决这个崩溃的现象，修改为
	FpgaGpioOperation.updateSettings(mContext, task, FpgaGpioOperation.SETTING_TYPE_NORMAL);
但是这个修改会导致重新开始打印的时候，下发的参数与原来打印时的参数不尽一致的情况，导致打印错误。
因此，恢复为原来的下发函数调用方法，因为有needRestore的守护，也不应该再发生崩溃的问题（已经确认过）

2022-1-23 220123-30782
==================
1. 取消在init的时候将BULK的RW区清0（恢复正常功能）
2. 在InkSchedulerFactory类中，同样加入通过自动判断Smartcard是否连接来决定走RFID还是SC的Scheduler

2022-1-23 220123-30781
==================
临时在init的时候将BULK的RW区清0

2022-1-23 220123-30780
==================
1. SC卡的修改
由于传统的支持Smart卡的img当中，选择PEN1，PEN2和BULK墨袋所对应的GPIO选卡命令为：
PEN1：GPIO_RFID_CARD2 
PEN2：GPIO_RFID_CARD3
BULK：GPIO_RFID_CARD5 
但是，在M系列当中，修改为
PEN1：GPIO_RFID_CARD1 
PEN2：GPIO_RFID_CARD3
BULK：GPIO_RFID_CARD4
因此，在新的IMG当中，需要支持判断IMG的种类，然后决定启用哪种配置。具体修改内容为：
1. 在SmartCard.so当中修改sc_gpio_adapter.c模块，追加一个gMImgType的变量，用来记忆img的种类
2. 在 sc_gpio_adapter.h中，追加一个类型定义，用来赋值给gMImgType，以区分img是M系列的img还是其他的
3. 修改SC_GPIO_ADAPTER_select_device函数，根据gMImgType的种类，决定下发哪种选卡命令
4. 在com_smartcard.c当中的Java_com_Smartcard_exist函数，追加一个从apk传递过来的参数，标识是否为M系列的img
5. 以上修改后，smartcard.so的版本更新为"1.0.375"，该版本与以前的版本exist函数不兼容
6. 在apk的InkManagerFactory类的getManager函数中，修改Smartcard的exist函数调用，追加判断是否为M系列img的参数
	SmartCard.exist(PlatformInfo.getImgUniqueCode().startsWith("M") ? 1 : 0)
！！！注意，只有这个版本以后的apk才能够支持M系列的SC功能（同时也可以支持传统img的SC功能）

2. 在RFIDDevice类中，如果写失败，将状态也设为STATE_RFID_VALUE_SYNCED，否则无法写卡234
（临时取消了写错误的检查，后续在根据情况是否打开）
（在smartcard.so里面临时增加了familyid的输出，已确认卡的类型）

2022-1-22 220122-30779
==================
临时修改sc_gpio_adapter.c里面选择PEN1，PEN2和BULK1时下发选卡命令，以确认M9是否能够正确选卡
BULK：GPIO_RFID_CARD5 -> GPIO_RFID_CARD4
PEN1:  GPIO_RFID_CARD2 -> GPIO_RFID_CARD1
PEN2:  还是GPIO_RFID_CARD3

2022-1-20 220120-30778
==================
在InkManagerFactory类的getManager函数中，如果img没有明确指定Smartcard，则判断SmartCard是否存在，如果存在，仍走Smart Card Manager，
否则走RFIDManager（主要目的是支持通用的M9img，插上SC就支持SC，不插就支持RFID）

2022-1-19 220119-30777
==================
测试页面，当写了OUTx后，如果INx读入为高，则会每间隔10ms持续读INx，直到读到低，或者切换到其他管脚测试，或者结束测试

2022-1-19 220119-30776
==================
1. 测试页面的启动方法改为在设置页面的右上部连续点击5次启动
2. 自动检测功能支循环一次
3. 手动点击OUTx后，自动读取INx的值加以显示
4. 统一自动测试和手动测试，自动测试相当于自动对OUT1-OUT8进行一次手动测试

2022-1-18 220118-30775
==================
1. 增加自动检测功能，循环设置OUTx为高，然后检测OUTx和INx的电平，OUTx如果不为高，INx不为低，则判断错误，相应按钮底色涂红色
2. 在设置页面，右上部快速点击5次以上打开测试页

2022-1-18 220118-30774
==================
1. 2022-1-13日修改，2021-11-9进行的RFID-CHECK的修改，将原来读取UUID修改为了读取SN，目的是防止用户打印前换卡。但是读取SN的时候没有将已经保存的SN清空，这样会导致如果用户拔卡而读不到数据时，会保留原值，导致拔卡也会通过检测的怪现象。在RFIDManager的case MSG_RFID_CHECK_NEXT处理时，增加了清空SN的操作。
2. 增加GPIO的OUT口和IN口的测试功能

2022-1-13 220113-30773
==================
增加写rfid时，检查写操作是否出错，出错3次后显示写出错信息框

2022-1-12 220112-30772
==================
点按开始打印按钮，延时1秒下发开始打印命令，以规避与beep的冲突（PG管脚组的设置冲突）

2022-1-11 220111-30771
==================
30770版本，间隔时间恢复为0，直接下发停止打印命令，400ms后，再次下发CLEAN命令

2022-1-11 220111-30770
==================
30769版本，间隔时间修改为400ms

2022-1-11 220111-30769
==================
点按停止以后300ms再下发打印停止命令，这样，beep应该已经完了，PG1，2应该会高起来

2022-1-6 220106-30768
==================
长清洗间隔从重复100次，改回重复50次，即执行5分钟

2022-1-5 220105-30767
==================
1. 启用新的清洗bin（purge4big.bin）是原来清洗bin的3倍量
2. 长清洗间隔从10秒改为6秒，重复100次，还是执行10分钟

2022-1-5 220105-30766
==================
1. 将长清洗从原来的清洗模式修改为普通的打印模式。具体实现看DataTransferThread类中的clean函数中的线程实现。
    即先下发
    FpgaGpioOperation.updateSettings(context, task, FpgaGpioOperation.SETTING_TYPE_PURGE1);
    然后，开始打印
    FpgaGpioOperation.init(mContext);
    然后，每个10秒下发一次打印数据（而非清洗数据，但数据本身是清洗的bin）
    FpgaGpioOperation.writeData(FpgaGpioOperation.DATA_GENRE_NEW, FpgaGpioOperation.FPGA_STATE_OUTPUT, buffer, buffer.length*2);
    下发次数完成后，停止打印
    FpgaGpioOperation.uninit();
2. 下发数据等待10秒的操作，原来使用的是tryLock，由于lock在相同线程当中已经获取，因此，此处无法实现等待10秒的功能，改用sleep

2022-1-4 220104-30765
==================
长清洗训话次数从30改为60，即长清洗执行10分钟

2022-1-4 220104-30764
==================
修改长清洗结束时执行mPurgeLock.unlock时出现异常的问题。这个问题原来就应该有，原因应该是获得锁和释放锁不是在一个线程里面

2022-1-4 220104-30763
==================
1. S5从60改为100
2. 清洗后等待改为3秒
3. 长清洗取消PURGE2的清洗流程，同时将循环数从15改为30，保持总的清洗次数和清洗时长不变
4. 长清洗也使用purge4big.bin
5. 增加启动长清洗时打印状态的判断，如果处于打印状态，则显示提示信息，不执行长清洗操作

2022-1-3 220103-30762
==================
清洗的bin使用事先准备的bin(purge4big.bin)，直接下发，不做任何加工。

2021-12-30 211230-30761
==================
1. 修改expandColumn函数列数的参数，原来没有考虑扩大36倍的问题
2. 清洗后从等待3秒改为等待6秒

2021-12-30 211230-30760
==================
30759版本的再编译

2021-12-30 211230-30759
==================
在PrintTask的run函数当中的循环语句开始处，增加判定是否为清洗状态的语句，用来避免在清洗的时候下发数据。因为原来清洗和打印是两个流程，不会出现冲突，但是将清洗改为正常打印下发后，清洗后等待3秒期间，如果不做这样的避让会错误下发打印数据，导致数据错结。但是清洗后等待3秒是否太长，这个需要商讨

2021-12-29 211229-30758
==================
1. 修改S5，S15，S21，S22，S23为下列固定值
            data[20] = 50;
            data[21] = 50;
            data[22] = 1000;
            data[14] = 500;
            data[4] = 1300;
2. 清洗缓冲区扩大3倍，原来扩大了12倍，因此扩大到36倍
3. 增加清洗缓冲区的slant功能
	expendColumn(rb, mBinInfo.mColumn, 100);
	rb = mBuffer;
4. 将expendColumn函数中对mTask等参数的判断，移到打印流程的调用expendColumn函数之前判断，因为expendColumn函数在执行清洗缓冲区的slant的时候，mTask为空，会导致null异常

2021-12-29 211229-30757
==================
无对应apk，空号

2021-12-16 211216-30756
==================
在修改界面的时候将获取扫描二维码焦点的那个无用ImageButton（id为msg_transfer1）设置成了invisible，导致该控件无法在获得焦点，而再次因为扫描二维码而打开导入导出对话窗。

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 【有关img升级的说明】                                                                                                                                                 +
+  = 升级内容                                                                                                                                                                  +
+      FPGA的状态设置转移到EXT-GPIO驱动里面                                                                                                                +
+  = 影响                                                                                                                                                                        +
+      新apk vs 老img ： 正常动作 （但GPIO管脚干扰的问题无法避免）                                                                               +
+      新apk vs 新img ： 正常动作 （GPIO管脚干扰的问题解决）                                                                                         +
+      老apk vs 老img ： 正常动作 （但GPIO管脚干扰的问题无法避免）                                                                               +
+      老apk vs 新img ： 无法正常打印                                                                                                                               +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
2021-12-14 211214-30755
==================
将FPGA的状态设置转移到EXT-GPIO驱动里面，目的是避免这两个驱动（FPGA驱动和EXT-GPIO驱动）都操作PG管脚组，并且无法互斥，而产生互相干扰。
这样操作以后，img也做了相应的修改，新的apk在原有的img上可以无障碍动作，但是互相干扰的现象仍然存在；旧的apk在新的img上面将无法实现对FPGA的控制，即无法打印（因为原来对FPGA的状态控制PG1，PG2都被移到了EXT-GPIO，FPGA驱动里面已经取消了，因此原来的apk下发的状态设置指令在新的img里面将不会得到执行，FPGA处于状态不受控的状态）

2021-12-03 211203-30754
==================
修改编辑DT信息的时候，进制编辑的内容区根据有效位数修改#号的个数，否则在编辑的时候无法视觉确认DT的长度

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
+ 【有关双列打印功能的开发说明】                                                                                                                                   +
+                                                                                                                                                                                    +
+ 1. 启用参数61，作为双列的位移量设置参数。0代表无双列打印，非0代表双列打印的位移量                                                  +
+     并且设置在FPGA下发参数25上；                                                                                                                                +
+ 2. 增加FPGA下发参数26，设置参数2；                                                                                                                           +
+                                                                                                                                                                                    +
+ 注1：当为双列打印的时候，将打印头类型（S10）按以下方法强制变更：                                                                            +
+         12.7 -> 1寸，12.7x2 -> 1寸x2， 12.7x3 -> 1寸x3，12.7x4 -> 1寸x4                                                                        +
+ 注2：当为双列打印的时候，S18的0x0010位，保持为1（S18或0x0010）                                                                            +
+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

2021-11-24 211124-30753
==================
1. 串口通讯方式修改
恢复串口JNI和SerialPort的原功能，但是仍然保留为PCCommand做的修改。
PCCommand的时候使用openStream函数，打开FileDescriptor的串口文件，用作后续使用InputStream和OutputStream进行通讯，主要目的传输文本报文。当然也可以传输二进制数据，但是接收的时候必须指定长度，否则陷入无限等待。
原有串口通讯的实现方式是非阻塞型通讯，即使没有数据也会立即返回（接收字节数为-1或者0），这个主要是为了满足当前串口通讯协议中有为文本的信息，并且长度不定，没有明确的停止符。因此必须靠超时来间接判断报文的结束（超时等待100ms）。
211102-30738版本做的修改，是把所有的通讯都统一到Stream的通讯方式了，因此会影响到原来串口当中非文本的报文的传递。所以必须恢复，区别使用。
2. 修改编辑页删除键的左右空白，因为看着比较窄，所以将原来的组有空白从5dp扩大到20dp
3. 取消编辑页的“新建”字样显示
4. 修改保存对话窗的按钮样式，与当前的其他按键统一

2021-11-23 211123-30752
==================
将StreamTransport类当中发送字符串的函数（原为write(String msg))，修改为在末尾追加一个换行符，否则，对方无法通过readLine读取字符串。修改后的函数更名为writeLine(String msg)。

2021-11-19 211119-30751
==================
FPGA下发参数26改为设置S2，而非S8

2021-11-19 211119-30750
==================
当为双列打印的时候，FPGA下发的参数S18的0x0010位，保持为1

2021-11-19 211119-30749
==================
更换新图标

2021-11-19 211119-30748
==================
1. 修改参数61的标记：双列偏移  （Nozzle offset）
2. 增加FPGA下发参数26，该参数下发内部参数8，打印方向的值。
    FPGA驱动在生成双列打印缓冲区的时候，如果打印方向为左，则首列后移，二列原位；打印方向为右，则首列原位，二列后移
(相应的FPGA的驱动也进行了修改。img版本更新)
3. 修改导入对话窗按钮的背景色。由于import_dialog.xml当中使用了ImageButton，但是没有设置背景，则系统采用了缺省灰色背景，通过设置背景解决了这个问题。

2021-11-18 211118-30747
==================
选表与1寸头不一样，更改为0xFFF0

2021-11-18 211118-30746
==================
对于双列打印支持。修改FPGA的下发参数，方法如下：
1. 当为双列打印的时候，将打印头类型（S10）按以下方法强制变更：
    12.7 -> 1寸，12.7x2 -> 1寸x2， 12.7x3 -> 1寸x3，12.7x4 -> 1寸x4
2. 当为双列打印的时候，下发选右表（S18），值设为与1寸头一样的0xFF0F

2021-11-18 211118-30745
==================
增加双列打印支持。启用C61作为双列的位移量设置参数。0代表无双列打印，非0代表双列打印的位移量
(相应的FPGA的驱动也进行了修改。img版本更新)

2021-11-17 211117-30744
==================
1. 上下滚按钮加宽，间隔加宽
2. Delete按钮加高（容器范围内顶天立地），加宽（按文字宽度）
3. 插入Obj对话窗修改，将原来的Button改为ImageView，增加固定按钮底色和边框，以前的Button是将图标本身作为底色，无法再加底色，靠切换图片切换显示状态。

2021-11-16 211116-30743
==================
配合30742版本修改底色，对界面做了大量修改，无法一一赘述，主要修改内容简介如下：
1. 图片图标均改为透明色，替换原有底色图标
2. 修改图标（透明底色图片图标或文字图标）的底色，使得其比底色稍微深一些
3. 增加bg_big_button, bg_mid_button, bg_small_button三种按钮底色方案，主要区别为白色边框的宽度有所不同
4. 修改大量layout文件，为平铺的按键增加divder属性，使其在显示时有一定的间隔，避免粘连一块的问题
5. 尽量对三个Tab（ControlTab，EditTab和SettingsTab）的按钮做了修改，和一些主要的对话窗进行了修改，可能会遗漏掉一些不常用的页面，随时发现，随时补漏修改

2021-11-10 211110-30742
==================
1. 背景色从#436EEE改为#7E9CF3。在res/values/color.xml 当中的
   <color name="background">#7E9CF3</color>
   项。
2. 按钮从直接贴图的方式改为底色#6786F0。在res/values/color.xml 当中的
   <color name="button_background">#6786F0</color>
   项。
3. 边框为白色(#FFFFFF)，按下时为橙色(#FFAA00）。在res/drawable/bg_big_button_normal.xml, res/drawable/bg_mid_button_normal.xml, res/drawable/bg_big_button_normal.xml当中，修改
<stroke
        android:width="4dp"
        android:color="@color/white" />
段当中的color值
在res/drawable/bg_big_button_pressed.xml, res/drawable/bg_mid_button_pressed.xml, res/drawable/bg_big_button_pressed.xml当中，修改
<stroke
        android:width="4dp"
        android:color="@color/orange" />
段当中的color值

2021-11-09 211109-30741
==================
由于读取RFID的UUID（0扇区，0块）返回FF的情形，导致checkUID失败。因此替换原来读数据（0x21）是否成功的办法检查UID，而是重新读取SN与保存的SN作比较，如果一致则成功，如果不一致就不成功。

2021-11-05 211105-30740
==================
去掉生成打印缓冲区过程当中的log输出，以提高生成打印缓冲区的速度。取消log的注释为“//./..."

2021-11-03 211103-30739
==================
大字机生成打印缓冲区时，位移量的计算修改为参数设置值（0基的10，11，18，19）除以24，其原理是大字节4mm是一列，参数设置的是1/6mm的单位数，因此，如果参数10（11，18，19都一样）设置24，才能够达到位移一位的效果

2021-11-02 211102-30738
==================
1. 追加StreamTransport公用类，使用标准的InputStream和OutputStream统一实现Socket和Serial等端口的通讯功能
2. 修改串口通讯库的实现方式，以前的收发报都是在jni的so里面实现，现在jni仅实现串口的打开和关闭，数据通讯部分使用StreamTransport公用类
3. 从ControlTabActivity类当中，将Socket通讯部分（ServerThread的建立，监听，ClientSocket的Accept，以及命令协议的解析和执行部分）移除至一下三个类
    3-1 PCCommandManager类
          统一管理从PC接收命令机制的管理。ServerThread的监听在这里实现，用来接收Socket的接入。并且提供接口，接受Serial端口的接入
    3-2 PCCommandHandler类
          通过调用StreamTransport类来获取PC端发送来的命令，解析并且执行
    3-3 ClientSocket类
          管理PC端连接的Socket

2021-10-26 211026-30737
==================
1. 修改SmartCardManager类当中synchronized的锁，以前的this可能有多种值，构不成绝对互斥
2. 追加downLocal的处理时bag值得减记，这里是个bug

2021-10-22 211022-30736
==================
1. PURGE下发从特殊下发改为按着打印下发，具体修改内容在DataTransferThread类中的purge函数
2. 修改S5的值，由400，改为2000，目的是避免清洗结束后，FPGA产生多余的PH14
3. 清洗等待1分钟取消，返回到等待3秒钟
4. E5, E6头的清洗时，加重恢复为16

2021-10-20 211020-30735
==================
1. 取消FPGA设置内容的强制设定，恢复正常设置
2. 取消S3，S4，S5的修改，恢复原来设置值
3. PURGE下发后等待1分钟
4. E5, E6头的清洗时，加重设为128

2021-10-20 211020-30734
==================
【临时版本】
调整强制设置FPGA设置内容的位置，使得输出log能够看到强制设置的值

2021-10-20 211020-30733
==================
【临时版本】
1. 修改FPGA设置下发内容，固定如下：
        data[0] = 1;
        data[1] = 4;
        data[2] = 10;
        data[3] = 61;
        data[4] = 170;
        data[5] = 1632;
        data[6] = 1;
        data[7] = 11;
        data[8] = 11;
        data[9] = 35;
        data[10] = 0;
        data[11] = 0;
        data[12] = 0;
        data[13] = 0;
        data[14] = 0;
        data[15] = 2;
        data[16] = 656;
        data[17] = 16;
        data[18] = 112;
        data[19] = 200;
        data[20] = 0;
        data[21] = 0;
        data[22] = 0;
        data[23] = 1;
        data[24] = 87;
        data[25] = 17;
        data[26] = 0;
2. 下发purge后，等待1分钟

2021-10-19 211019-30732
==================
1. purge下发后，恢复等待3秒
2. FPGA 参数暂时修改为
S3=80
S4=200
S5=1600

2021-10-18 211018-30731
==================
purge下发后，由等待3秒改为等待6秒

2021-10-11 211011-30730
==================
1. 修改串口协议10，追加第14位赋给DT1的功能
2. 修改BarcodeObject中EAN13打印数字信息的错误

2021-9-28 210928-30729
==================
追加串口协议10

2021-9-27 210927-30728
==================
串口协议9修改为支持FIFO的功能，与扫描协议1FIFO类似

2021-9-26 210926-30727
==================
1. 追加参数57选项，设置外部输入的动作类型，0：无动作；1：管理打印；2：打印镜像。该修改涉及img的fpga驱动的更新。涉及，
    1-1. ControlTabActivity中对PI11按钮监视中判断参数57是否为管理打印
    1-2 SystemConfigFile中setParam的时候，如果为参数57则向fpga下发最新设置值
2. 追加串口协议的错误返回，增加接口onError，支持当发生错误的时候显示提示信息
3. 修改img的版本显示信息，从VVxxYMMDDHHmm方式，改为VVVVVYYMMDDHHmm，其中VVVVV为4位或者5位的img分类唯一码，YYMMDDHHmm为img生成的年月日时分信息

2021-9-24 210924-30726
==================
追加串口协议9

2021-9-23 210923-30725
==================
1. 将为了手机版进行了修改的control_frame恢复为原来的内容。因为，修改了的layout预览区是自动取高度的，而原来是设置固定高度的。由于设备启动之后会出现一段竖屏的状态，再回到横屏，导致预览区的高度是按着竖屏计算的，因此高度就被放大了。导致预览内容只能看到一部分
2. 修改字号编辑对话窗没有支持96DN的BUG
3. 电池容量为0的时候，为了开发手机apk修改为了显示电池低，恢复到原来的不显示图标

2021-9-18 210918-30724
==================
1. 修改长按开始打印后，点按屏幕停止打印，再松开后，再次长按开始打印无反应的问题
 （调整接收到松开事件后的状态修改为止，之前如果停止了打印，则即使松开也不会再进行状态修改）
2. 以长按的状态开机时，画面不显示的问题。调整Timer启动，延迟3秒启动

2021-9-18 210918-30723
==================
增加PI11端口监视功能，长按开始打印，松开停止打印。（同时修改img中的ext_gpio驱动）

2021-9-18 210918-30722
==================
在SerialHandler类中追加数据源的log输出

2021-9-17 210917-30721
==================
追加扫描协议1的FIFO机制。该协议的宗旨是持有一个FIFO数据区，扫描的到的内容追加到该FIFO的后部，打印时从FIFO的头部取，不再随扫描随修改打印缓冲区

2021-9-16 210916-30720
==================
(1) 串口6协议的长度检查修改为正确的长度值(33->19)@DataTransferThread.java类
(2) 补齐96DN头的修改遗漏@Message Object类的getDisplayFs函数，没有追加对应于96DN的处理

2021-9-14 210914-30719
==================
取消DataTransferThread类中setScanDataToDt当中对协议的重复检测

2021-9-9 210909-30718
==================
在ControlTabActivity类中的refreshInk函数的log输出中，增加版本号信息

2021-9-1 210901-30717
==================
1. 修改BufferRebuilder类中初始化函数里面获取mByteBuffer时的大小计算方法。取消mColNum * colCharNum，直接用src.length。因为如果使用前者，mColNum = src.length / colCharNum，如果不能整除，则计算结果将小于src.length，导致后续出现溢出异常
2. SmartCardManager类中的墨位阈值修改为138
3. 恢复210730-30687版本当中对ILG和OIB写入功能（之前为该功能被屏蔽，版本号1.0.372），新的版本号为1.0.373

2021-8-31 210831-30716
==================
修改Smartcard的时候，P2不减锁的问题，因为减锁操作使用的是赵工InkScheduler的接口，这里在Smartcard的情况下，没有根据实际情况（SmardCardScheduler的count函数）

2021-8-31 210831-30715
==================
修改打印缓冲区生成逻辑：
   （1） 每相邻列中的第0，2，3，4，5双字节追加空列；第1双字节不变
   （2） 每列的位右移从位移4个点（列）修改为8个点
   （3） 总宽度设为512（原宽度）+8（位右移宽度）

2021-8-27 210827-30714
==================
1. 对30713做修改。检索操作按着5个头进行。但是在生成打印缓冲区的时候按着6个头的空间生成。修改原来一概按5个头或者6个头处理所有内容
2. 对于96Dot喷头，调整为第1，3，5，7位后移4列，第0，2，4，6位不动。

2021-8-26 210826-30713
==================
E5X48和E5X50喷头类型的打印头数量从5改为6，即按着6个头生成数据（但是，在实际打印的时候，FPGA会不安装第6个头，从而实际上忽略掉第6个头的数据）

2021-8-26 210826-30712
==================
追加E5X48和E5X50喷头类型

2021-8-24 210824-30711
==================
1. 取消30711版本追加的log输出
2. 在RFIDDevice类中的onFinish函数里面，当读到数据后，之前调用的parseRead会调用decryptInkMax函数，该函数会使用5个字节，从而导致30708版本将InkLevel后面的00处添加了具体内容后，可能会导致inklevel值被放大，从而导致ink>max，返回100%。因此将parseRead更名为parseMax，进处理读取最大值。同时追加parseLevel，用来处理InkLevel，其内部调用decryptInkLevel，该函数只是用4个字节，因此可以避免原来的错误。

2021-8-24 210824-30710
==================
在RfidManager类的getInkPercentage函数里面增加ink和max的log输出，已确认计算错误的原因

2021-8-23 210823-30709
==================
在RFIDDevice类中追加一个TmpInkLevel变量，与CurInkLevel完全保持一致，主要是为了规避down函数进行减锁时出现不可预测的计算错误（虽然这种可能性微乎其微）。测试一下看看吧。

2021-8-23 210823-30708
==================
1. 更换字体
2. 设置ink16字节的其他部分为一定墨量值的组合或者倍数组合。即[18 03 00 00 00 00 00 00 00 00 00 00 00 00 00 00] -> [18 03 00 00 XX XX XX XX XX XX XX XX XX XX XX XX]
3. 取消SmartcardManager类当中downLocal函数里面写卡后再次读卡更新本地值的操作

2021-8-20 210820-30707
==================
由于复制移到了倾斜的前面，复制的时候做的考虑倾斜的判断取消（仅对大字机，HP头无影响）。

2021-8-17 210817-30706
==================
30705版本调换位置以后，由于原来代码当中，rebuildBuffer函数里面才将mPrintBuffer设置给mBuffer，因此提前使用mBuffer会导致空指针发生

2021-8-17 210817-30705
==================
调整重复打印的重复和倾斜计算顺序，先重复后倾斜。以前的实现是先倾斜后重复。(DataTask.java的getPrintBuffer函数)

2021-8-16 210816-30704
==================
修改RFIDOperation.c当中read函数的退出条件，原来的退出条件判断没有考虑验证码可能为0x10的情形，导致该情形出现的时候不会退出。但是现在的修改方法无法避免连续转义的情形带来的不退出的问题。

2021-8-16 210816-30703
==================
更换所有字体

2021-8-16 210816-30702
==================
1. 增加96DN头类型
2. 取消打印10次减锁一次的修改(30701)，恢复正常
3. smartcard.so中未实际写ILG和OIB的功能保留

2021-8-13 210813-30701
==================
【临时版本】
1. 取消30699版本中第4条修改，writeInk后读取写入的值的操作
2. 将30700第2条修改中的mcountdown的值设为10。目的是给其他头的RFID写入时间

2021-8-13 210813-30700
==================
【临时版本】
取消30688版本当中，在ControlTabActivity类的MESSAGE_COUNT_CHANGE中增加downLocal的调用。改为，将DataTransferThread类中的countDown函数的mcountdown设为1，使得同样可以达到打印一次减锁一次的效果

2021-8-12 210812-30699
==================
对smartcard.so做了下列修改：
1. 取消sc_gpio_driver.c的SC_GPIO_DRIVER_ioctl函数在ioctl返回ECOMM错误以外的错误时进行多次尝试，应该时ext_gpio的问题导致返回值不正确，但是设置是有效的，如果做多次尝试，则会耽误500us左右的时间，并且导致其他线程占用cpu
2. 取消sc_common_mem_access.c当中write系列函数在失败的时候尝试100次的设置，因为一旦失败可能失败会延续，100会耽误很长的时间。取消尝试以后，如果写入失败则忽略，等待下次写入时成功
3. 在com_smartcard.c函数里面追加mutex机制，java中采用的线程排斥机制似乎不起作用，尝试c语言级别的线程排斥
4. 在RfidDevice当中，writeInk后读取写入的值，以确认是否一致
5. 追加1+L和1+R字体

2021-8-11 210811-30698
==================
在【临时版本】30697版本的基础上，追加打印条数200条的限制。限制属性在Configs.java类中定义，打开对话窗中根据限制属性进行限制或不限制

2021-8-11 210811-30697
==================
【临时版本】smartcard.so中的hp_smart_card.c中的smart_card_trans_write中，暂时取消对奇偶校验值的判断，以保证不明原因奇偶校验不一致导致的程序退出(1.0.371)

2021-8-10 210810-30696
==================
【临时版本】smartcard.so中的hp_smart_card.c中的smart_card_trans_device_init中，当出现parity失败的时候输出parity信息，但不返回错误，并且将新计算的校验值设置给运行环境，但是也许设置的不全面，后续flush的时候还是返回奇偶校验错误，导致死机。做了不全修改，但不确定，需要验证(1.0.370)

2021-8-9 210809-30695
==================
【临时版本】smartcard.so中的hp_smart_card.c中的smart_card_trans_device_init中，当出现parity失败的时候输出parity信息，但不返回错误，并且将新计算的校验值设置给运行环境，使得后续的flush能够避开这个错误的影响（否则无法写入），实现再次写入(1.0.369)

2021-8-9 210809-30694
==================
【临时版本】smartcard.so中的hp_smart_card.c中的smart_card_trans_device_init中，当出现parity失败的时候输出parity信息，但不返回错误，目的是使得处理能够正常进行。但是，由于已经出现奇偶校验错误，因此此时的数据已经是错误的了。对于这个错误数据，当其为ILG数据时，做了尽量预防的修改。原则是由原来的由高位根据ILG对获取百分比，对OEM只进行修正，改为由低位获取百分比。这样可以避免ILG写错带来的负面影响，也对OEM区写错误有一定的修复作用(1.0.368)。
即：如果锁值写入不正确可以大范围修正错误；如果ILG写入错误，可以大范围修正错误（但是如果1和1之间的0被填满时会跳一个百分比）

2021-8-8 210808-30693
==================
【临时版本】smartcard.so中的hp_smart_card.c中的smart_card_trans_device_init中，当出现parity失败的时候输出parity信息(1.0.367)。

2021-8-7 210807-30692
==================
【临时版本】增加SC卡访问出现异常的时候，在对话窗中显示提示信息（SmartCardManager类中的downLocal函数）。

2021-8-6 210806-30691
==================
【临时版本】在30690版本基础上，恢复checkUID函数当中的init函数调用。

2021-8-5 210805-30690
==================
【临时版本】在30689版本基础上，暂时取消checkUID函数当中的init函数调用。同时恢复30689版本downLocal函数的写操作

2021-7-30 210730-30689
==================
【临时版本】在30688版本基础上，暂时取消downLocal函数的实际硬件调用，变为空函数

2021-7-30 210730-30688
==================
【临时版本】在30687版本基础上，修改ControlTabActivity类的MESSAGE_COUNT_CHANGE响应，增加downLocal的调用，目的是每次打印下发都写SC卡，加速SC卡的测试速度

2021-7-30 210730-30687
==================
【临时版本】暂时取消smartcard.so库中downLocal函数中对ILG和OIB的写入操作，以节省SC进行大量测试。(版本升级为1.0.366)

2021-7-29 210729-30686
==================
smartcard.so库中SC_GPIO_DRIVER_ioctl函数如果返回ECOMM错误则假设是因为信号干扰，尝试100次。均失败才作为失败处理。(版本升级为1.0.365)

2021-7-29 210729-30685
==================
30682版本修改重复打印次数上限值时的修改遗漏（有效值范围设置的xml没有修改），在30684基础上进行修改

2021-7-28 210728-30684
==================
1. 暂时恢复预览图片功能
2. 预览图取消使用经过后期处理的图片，使用原始生成图片

2021-7-28 210728-30683
==================
修改30681修改项目3，大于等于100时乘8

2021-7-28 210728-30682
==================
重复打印次数上限改为30

2021-7-28 210728-30681
==================
1. 恢复墨位加墨阈值
【临时版本】
2. 暂时取消预览图片显示功能
3. 重复打印在大字机倾斜参数36大于100时，采用参数7乘8，其他的情况下参数7除以4

2021-7-28 210728-30680
==================
【临时版本】修改210727-30677版本错误

2021-7-28 210728-30679
==================
【临时版本】修改210727-30676版本错误

2021-7-28 210728-30678
==================
【临时版本】修改210727-30675版本错误

2021-7-27 210727-30677
==================
【临时版本】墨位加墨阈值恢复为140

2021-7-27 210727-30676
==================
【临时版本】墨位加墨阈值恢复为138

2021-7-27 210727-30675
==================
【临时版本】墨位加墨阈值恢复为136

2021-7-27 210727-30674
==================
1. 修改重复打印的打印缓冲区生成算法。原来的算法如果打印内容大于限定的打印缓冲区块的宽度，会延展出去。不符合切掉尾巴的设计初衷，进行了修改
	if(i < sysconf.getParam(SystemConfigFile.INDEX_PRINT_TIMES) - 1) {
		caBuf.append(mBuffer, 0, Math.min(mBuffer.length, maxColNumPerUnit * mBinInfo.getBytesFeed() / 2));
	} else {
		caBuf.append(mBuffer, 0, mBuffer.length);
	}
    中途的都会被切割，只有最后的内容会全部展示
2. 修改预览图片的生成逻辑。根据特殊情况的高度，从缓冲区的具体长度计算列数，取消实际计算应该的列数，这样会避免出现错误

2021-7-26 210726-30673
==================
1. 追加重复打印的墨水消耗量计算(DataTransferThread的threshold函数)
2. 追加韩文字符串

2021-7-26 210726-30672
==================
1. 修改重复打印的次数限制，原来的限制会少一次（DataTask类中getPrintBuffer函数中的下列语句sysconf.getParam(SystemConfigFile.INDEX_PRINT_TIMES)是否减1）
	for(int i=0; i<sysconf.getParam(SystemConfigFile.INDEX_PRINT_TIMES); i++) {
2. 修改预览图片生成，考虑自动多头（R6，E6，E1，重复打印）等

2021-7-26 210726-30671
==================
追加打印缓冲区预览功能。当前的预览是显示一个预先生成的固定内容预览图，无法看到具体的打印内容。修改以后，可以看到具体的打印内容，但是是以下发给fpga的数据格式呈现的，可能与实际打印出来的效果不一致（这个是因为有一些根据打印头进行的操作，需要观察时清楚这些基于硬件的操作）
具体的操作方法是，当在打印状态下，点击预览图片则在固定内容预览图和实际打印内容预览图之间进行切换。

2021-7-23 210723-30670
==================
(1) 确定30669的版本
(2) 追加重复打印功能。即触发一次打印多次的功能
   (2-1) 将参数41作为重复次数的设置项，有效值为0-20，其余值均强制设置为0
   (2-2) 修改参数设置页面中有关该参数的设置操作
   (2-3) 追加相应的打印缓冲区的生成逻辑

2021-7-21 210721-30669
==================
【临时版本】
修改smartcard库中的SC_I2C_DRIVER_read和SC_I2C_DRIVER_write函数，完善当打开文件后如果出现错误退出函数时没有关闭文件的问题（加入SC_I2C_DRIVER_close(fd)函数调用）

2021-7-20 210720-30668
==================
【临时版本】
恢复SmartCardManager类中downLocal函数中实际对SC的操作，将这部分操作改在线程里面执行

2021-7-20 210720-30667
==================
【临时版本】
恢复DataTransferThread类中countDown函数里面对mInkListener.onInkLevelDown(i)和mInkListener.onCountChanged()的调用。注释掉SmartCardManager类中downLocal函数中实际对SC的操作，因为这个是通过I2C总线进行的，比较慢

2021-7-20 210720-30666
==================
【临时版本】
暂时取消DataTransferThread类中countDown函数里面对mInkListener.onInkLevelDown(i)和mInkListener.onCountChanged()的调用，这两个调用都会产生在UI线程的一系列操作，可能会占用太多CPU。主要目的是解决打印过程当中出现ANR异常的问题

2021-7-15 210715-30665
==================
300dpi系统当中，如果参数3参数分辨率选择150dpi，原有的Threshold计算中bold变量由于采用的是整形，会得到0，而非0.5。会导致计算错误。修改为float型就可以了

2021-7-14 210714-30664
==================
30663修改(2)的计算方法适用于E6x1

2021-7-14 210714-30663
==================
(1) 墨位加墨阈值恢复为135
(2) 计算Threshold时的bold的计算方法，当300dpi的时候，如果打印头为E6类型，由于已经在锁上做了对应，暂时按原来的处理
bold = config.getParam(SystemConfigFile.INDEX_PRINT_DENSITY)/150;
(3) 增加E6x1打印头

2021-7-12 210712-30662
==================
墨位加墨阈值为139

2021-7-12 210712-30661
==================
墨位加墨阈值为137

2021-7-9 210709-30660
==================
修改计算Threshold时的bold的计算方法：
如果系统是300dpi的，使用参数2除300；如果系统是150dpi的，使用参数2除150
	if(Configs.GetDpiVersion() == FpgaGpioOperation.DPI_VERSION_300) {
		bold = config.getParam(SystemConfigFile.INDEX_PRINT_DENSITY)/300;
	} else {
		bold = config.getParam(SystemConfigFile.INDEX_PRINT_DENSITY)/150;
	}

2021-7-2 210702-30659
==================
修改扫描协议4的实现方法：
(1) 当接收到Resetcode7799时，不仅要对Index进行清零，也要把上次接收到的字符串标识清空
(2) 取消本次扫描内容与上次扫描内容重复的时候忽略本次扫描内容的判断，都进行处理

2021-6-11 210611-30658
==================
(1) 取消网络打印状态标识（StopFlag），该表示将导致网络停止打印命令对手动开始的打印任务无效
(2) 修改E6横向复制点数的算法（getInkThreshold函数）不能乘(PrinterNozzle.E6_PRINT_COPY_NUM-1)，因为取消了单数行加1的操作，应该直接乘PrinterNozzle.E6_PRINT_COPY_NUM
(3) 修改生成显示Dots数的算法（PrinterTask里面），R6头和E6头应该连续判断，不应该分开，由于分开，计算值被加入两次，导致显示字符串不对（实际上每个值被使用了2次）
【注】由于有一批机器已经出货，所以(2)恢复原样，将错就错

2021-6-7 210607-30657
==================
(1) 取消用户页面2的主页面编辑框
(2) 修改BaseObject当中meature函数，此函数中对宽度做了调整，但是对结束坐标没有调整，导致生成打印缓冲区不对

2021-6-7 210607-30656 （跳过）
==================

2021-6-4 210604-30655
==================
(1) 修改用户界面2的文字显示
    打印 -> 启动
    选择文件 -> 选择数据
    导入 -> 导入数据
(2) 修改状态条显示，将上下键和墨水量显示位置对调
(3) 修改内容加长修改时，加长部分不显示也不打印的问题

2021-6-4 210604-30654
==================
修改SmartCard的BULK墨量，从固定值改为根据DropVolume计算
bulk 计算 
DV 29 对应3150
DV x=20-35 ：   3150*(29/X)     
DV x < 20  or  X>35:    4700

2021-6-3 210603-30653
==================
(1) 修改用户界面1，恢复小人图标，恢复头部的功能切换按钮区
(2) 修改用户界面2，取消独立页面，改为由ControlTabActivity页面衍生而来

2021-6-2 210602-30652
==================
(1) 修改首页预览区显示方法，保留切图的功能（因为如果图片的宽或者高大于4096时，图片无法设置给控件），同时保留上次修改的延时显示功能，否则可能在启动显示的时候，控件高度为0，无法完成正常显示
(2) 修改用户界面1的修改，取消头部的功能页面切换按钮
(3) 追加用户界面2

2021-5-25 210525-30651
==================
修改加重设置增加为2400后，设置超过750以上数值返回150的问题。原因为原来的范围设置最大为750

2021-5-25 210525-30650
==================
取消DT生成vbin的功能，因为DT是在生成打印缓冲区的时候，根据具体内容实时生成，不需要vbin。反倒，生成vbin的话，原来支持128字符，在分辨率大的打印头时（25.4*n）会由于试图生成超大位图而崩溃。

2021-5-24 210524-30649
==================
修改扫描协议4接收到扫描字符串赋值时的bug。

2021-5-24 210524-30648
==================
清洗间隔改为3秒。

2021-5-22 210522-30647
==================
25.4x(1-4)头，打印的时候，S18[4]强制设为0（即取消30644版本的修改）。

2021-5-22 210522-30646
==================
(1) 修改str_print_count字符串中文版与英文版的不一致
(2) 增加扫描协议4
(3) 修改动态文本的实现策略。改为内部持有10个动态文本的保存皿，每个按序号与DynamicObject内的动态文本特有的Index匹配。DynamicObject的取值从该保存皿中获取，保存皿的取值通过串口，扫描或者网络修改。该保存皿全局有效，影响所有各自对应Index的DynamicObject的取值。保存皿的取值在关机后消失
(4) 打印的时候，E6不能允许选反表， 即S18[3:0]取0
(5) 加重取值增加900，1200，1800，2400。同时修改img一对应最大值2400（img内部值为16）
(6) E6清洗时加重取值2400

2021-5-21 210521-30645
==================
(1) 清洗时，R头E头的分辨率改设为9，目的是增加打印的浓度
(2) 增加USER_MODE开关，可以在编译之前设置，用来决定用户特殊界面（小人图标）的显示与否。改开关在Configs类中
(3) 修改主页面预览图显示的实现方式，主要目的是为了解决偶尔不明原因的预览画面不显示。经调查发现不显示是因为预览显示区的LinearLayout的高度还没有被设置引起的（这是一个时机的问题）

2021-5-20 210520-30644
==================
(1) 25.4x(1-4)头，打印的时候，S18[4]强制设为1
(2) 清洗的时候，都选反表，S18[3:0]都设为1

2021-5-20 210520-30643
==================
修改预览页面一旦打印之后，预览图会被横向拉长的问题。原因是font==mFont，应该是font.equals(mFont)

2021-5-19 210519-30642
==================
预览页面显示的预览图使用DataTask的mBgBuffer生成，否则使用mPrintBuffer的话，会将所有对打印数据做的变形都会复现。使用mBgBuffer也不能全部避免，多头的头间间隔会体现出来。同时，使用mBgBuffer的时候，不能包含变量。

2021-5-18 210518-30641
==================
修改30640版本BUG

2021-5-18 210518-30640
==================
初步完成增加预览打印页面功能，待测试确认

2021-5-17 210517-30639
==================
增加预览页面prototype（仅为页面确认，无实际动作，不可发布）

2021-5-10 210510-30638
==================
恢复加墨处理部分并发执行（与30635版本相同处理方式）

2021-5-10 210510-30637
==================
恢复加墨处理部分的串行实现（FPGA似乎在打开阀之后1秒钟关闭，10秒钟之内不反应任何开发操作）

2021-5-8 210508-30636
==================
将打印计数器调整的函数afterDataSent改为在读到打印数量发生变化时调用，取消原来在empty事件处理中调用，这样可以保证主页面显示的打印数量与实际打印数量一致。但是否会引起其他的问题需要确认。

2021-5-8 210508-30635
==================
加墨处理部分单独在新的线程当中执行，以避免双头时的串行处理

2021-5-8 210508-30634
==================
(1) 修改FIFO模式下获取打印次数处理中的bug
(2) 取消gpio的read函数的log输出，无意义输出太多

2021-5-7 210507-30633
==================
(1) SmartCardManager加墨操作的间隔从32秒（32000ms)改为11.5秒（11500ms)
(2) 增加FIFO情况下根据实际打印数量修改计数器值。以前只要下发就会修改计数器的值，并且保存在RTC的不挥发记忆体里面。如果FIFO打印的情况下，由于下发的数量比较多，停止打印时，可能apk下发给FPGA驱动的打印作业并没有都完成，这会导致下次打印的时候，上次下发但没有打印的部分的计数器值会被跳过。为了解决这个问题，修改如下：
     1- 如果启用了FIFO模式（FIFO的值大于1）并且不是群组打印（mTasks的大小为1），则认为是在使用FIFO模式进行打印
     2- 当处于FIFO模式打印的时候，跟随下发进行的计数器调整仅影响当前的数值，不保存到不挥发记忆体。并且，随时检测FPGA实际打印完成的数量，据此修改不挥发记忆体的计数器值
     3- 如果不处于FIFO模式，则跟随下发进行计数器值调整时，直接修改不挥发记忆体内容

2021-5-7 210507-30632
==================
修改4个打印头offset的最小值(1-->0)和缺省值(1-->0)

2021-4-28 210428-30631
==================
(1) 增加群组输入名称对话窗
(2) 提高系统DPI获取函数的鲁棒性。很旧的img没有返回值，可能是一个不确定的数。因此，如果使用很久的img时，可能会因为这个不确定值导致死机

2021-4-26 210426-30630
==================
双头连供在打印的时候，会出现卡住的现象。此时打印线程既没有退出，也没有执行，非常奇怪。log里面看不出出什么问题了。只能推测可能是线程太多导致的。因此，将SmartCardManager类里面的所有有关线程的生成部分，均改为使用线程池来实现，这样可以避免产生多余的线程

2021-4-23 210423-30629
==================
(1) 取消20628修改(3)恢复原样，但是当打印头为大字机的时候，设置加重参数为8
(2) R6和E6头的单位宽度，在300DPI的时候需要加宽一倍

2021-4-23 210423-30628
==================
(1) 修改30627(1)修改的bug，因该设给data[15]，设给了data[9]
(2) 修改30627(2)修改的bug，scaleW应该为152.194*2，原来的修改没有这个成2。这个是赵工的特殊处理，不知道为什么
(3) 修改清洗时的加重参数，强制设为2

2021-4-23 210423-30627
==================
(1) 当打印头类型为打字机的时候，下发参数时，根据img驱动的加重类型，如果为300dpi的，下发加重参数为2，如果为150dpi则下发1
(2) 修改9MM，E6打印头类型是，生成打印缓冲区时的scaleW和div计算公式

2021-4-20 210420-30626
==================
(1) 将DataTransferThread类的打印线程中，收到fpga驱动来的empty事件（即底层要数）后将mNeedUpdate设为false的操作移到真正下发数据后设置
     因为在网络快速打印的首发之前和串口协议3（扫描3）时，由于不首先下发数据，会频繁获得empty事件，如果在外面清除mNeedUpdate，会导致真
     正有了数据后不能被下发（因为这些下发是参照mNeedUpdate进行的）
(2) 将DataTransferThreadDataTransferThread类的打印线程中，收到fpga驱动来的empty事件（即底层要数）后，调整计数器的操作移到真正下发数据
     后操作。因为在网络快速打印的首发之前和串口协议3（扫描3）时，由于不首先下发数据，会频繁获得empty事件，会导致计数器疯狂计数
(3) 增加reportEmpty标识，主要是控制网络快速打印的首发之前和串口协议3（扫描3）时频繁获得empty事件而输出log，导致该log霸屏。该标识在下发
     了新数据后清除，用来显示下次的empty事件
(4) 调整非网络快速打印时，更新下发的逻辑。
     当数据源为串口3时，由于数据只被允许发送一次，因此只有数据没有下发时才执行下发，设置已下发标识。并且下发新数据，而非更新数据。如果已经
     下发过，就不会再收到empty事件，也就不会再次下发。只有底层打印之后，才能够收到empty事件，清除已下发标识，才会再次收到数据后下发
     当数据源为非串口3时，为保证更新下发不与不会因为正在打印的时间点而落后于打印操作而篡位到后续数据，检查是否有empty事件，如无才下发更新
     数据（其实，底层已经处理过，即使更新下发篡位到后续的任务，也不影响empty事件的发生，从而后续的真是数据会覆盖掉这个篡位数据，因此这个判
     断不太必要，但也无碍）
(5) 取消网络快速打印的首发数据下发时对底层是否不在要数（未发送empty事件）的判断，因为此时底层会频繁发送empty事件，导致首发不会被执行。
     同时，首发数据按新数据下发。

2021-4-17 210417-30625
==================
(1) 增加从img获取版本信息的功能，目的是在apk可以判断使用的img的版本。
(2) 修改PlatformInfo类中的DotMatrixType变量的处理，取消设置操作，保持原值0的状态。因为1代表使用DotMatrix，已经取消。2代表8个头，没有使用过
     如果保留设置，则会在SettingsTabActivity类的saveParam函数中，mSysconfig.getParam(30)==7的时候被设置为1，导致MessageTask类调用saveBin保存bin的时候会跑到
     saveBinDotMatrix函数里面去，有时会死机，（推测）有时会保存不对

2021-4-15 210415-30624
==================
修改30620版本出错回送报文的功能，只在地址相同的情况下才回送报文。

2021-4-15 210415-30623
==================
尝试修改串口运行过程当中死机的问题，可能是由于jbytearray没有释放的原因。

2021-4-15 210415-30622
==================
修改30620版本对有效性检测时，没有考虑写命令和读命令长度不一样的问题。

2021-4-15 210415-30621
==================
(1) 串口协议8，写命令回复中追加写入数据和品种代码

2021-4-15 210415-30620
==================
(1) 追加串口协议8命令有效性检验，并且在出错时会送错误报文
(2) 修改启动打印时对DPI合法性判断的位置，以前的位置会导致打印数据没到位的情况下(mDataTask==null)，获取信息，导致异常发生。

2021-4-15 210415-30619
==================
修改串口8协议的读数据返回，原来只支持一个数据，现在加进去品种代码

2021-4-15 210415-30618
==================
修改ByteArrayUtils里面将字节数组变换为可视字符串的算法。可能字节数太多（如920字节）变换成字符串会比较长，超过系统的限制，系统对字符串的限制多长还不太清楚

2021-4-15 210415-30617
==================
恢复30613版本中定义的300DPI支持功能，并且进行补充修改。img也同时更新

2021-4-14 210414-30616
==================
对于30613中取消BCD转换的操作，修改遗漏的返回报文生成时的本机ID计算

2021-4-13 210413-30615
==================
取消3月5日30592版本当中，在打印当中进行清洗的时候取消停止打印和重开打印的操作，恢复为先停止打印，然后下发清洗数据，然后重开打印。但是，保留取消再次下发上次打印数据的操作

2021-4-13 210413-30614
==================
(1) 调整串口8协议格式，调换写入数据和品种代码位置
(2) 调整字节顺序。AABBCCDD格式接受的数据按CCDDAABB解读，然后变换为10进制，赋值方法照旧

2021-4-11 210411-30613
==================
(1) 串口8，取消对接收到的地址进行BCD转换
(2) 串口8，追加品种代码，共4位，最后一位赋给dt3，倒数第2，3位赋给dt2
(3) 300DPI对应正在修改，需要新的img支持，暂时屏蔽

2021-4-9 210409-30612
==================
(1) 将MessageTask类中生成和保存bin函数里面，对于getResolution函数的引用修改至非大字机分支中，否则会导致在300dpi的时候不会在打印头之间插空
(2) 将DataTask类中refreshVariable函数里面，对于getResolution函数返回true（300dpi）的时候，仅对非大字机的宽和div进行调整，否则会对大字机产生副作用
(3) 在BaseObject，DynamicText和ShiftObject里面，根据getResolution的处理，没有排除大字机，但是由于使用了PrinterNozzle类中的getFactorScale函数，返回值会根据头的类型不同而不同，因此步修改也没有影响

2021-4-6 210406-30611
==================
(1) 将MessageObject类中的mHighResolution固定为true，以实现300DPI的功能

2021-4-4 210404-30610
==================
(1) 修改DataTask类中refreshVariable函数里面生成scaleW，和div的算法，原来的没有考虑308，按304计算的，会缩小
(2) 恢复动态条码不生成1.bin，静态条码打印时不重新生成
(3) 修改9MM头读入时的mProportion的计算，应该为1，以前使用的是112/152，会在读入时导致变宽

2021-4-1 210401-30609
==================
(1) 清洗设置参数，bold设置为打印头的数量，如果是R6或者E6头，则设置为6

2021-3-30 210330-30608
==================
(1) 取消30606的修改(1)，scaleW和scaleH应该为104而不是112
(2) 清洗时(Purge)，头类型（FPGA参数的data[9]，即第10个参数）设置为25.4x4（值为19）

2021-3-23 210323-30607
==================
取消30606版本(3)修改的内容，恢复原样

2021-3-23 210323-30606
==================
(1) 修改9MM打印头打印时，高度被缩小的问题。原因是PrinterNozzle类当中计算scaleW和scaleH的地方，使用了104(13个字节)，应该使用112(14个字节)，因为这里需要考虑双字节
(2) 修改PrinterNozzle里面的PhysicalRatio，原来是使用9.0f/104，但是根据其他算式，这里应该是208（不是很确定）
(3) 修改打印中途更换打印头（RFID）不检测的问题。暂时在RfidTask类当中的execute函数里面加了一个调用RfidManger类的checkUID的功能，经过测试，中途去除rfid会报警

2021-3-19 210319-30605
==================
E6和R6打印头，最后一个单元不添加空格的BUG修正，原来是以其他条件做的组合判断，导致如果是最后一个单元需要添加空格的时候，不是跳过不添加，而是试图添加原来的正是内容，但此时原来的内容已经加完，会导致越界崩溃

2021-3-19 210319-30604
==================
尝试解决没有开始打印的时候点击Purge清洗时崩溃的问题。
在 public void purge(final Context context) 函数中，purge结束以后再次下发参数的时候，使用了mDataTask.get(mIndex)。这是mDataTask是null

2021-3-18 210318-30603
==================
E6，R6打印头取消每行最后一个单元的空格补齐

2021-3-18 210318-30602
==================
E6打印头改为单数行不向后位移一个单位

2021-3-16 210316-30601
==================
修改保存+打印时，如果RFID验证码不正确不阻止打印的问题

2021-3-15 210315-30600
==================
添加俄文strings.xml

2021-3-8 210308-30599
==================
参数58该名称。中文简体/繁体改为：地址；其他语种改为IP

2021-3-8 210308-30598
==================
修改串口协议8接收数据处理，提出到一个独立函数，显示接收到的串口信息

2021-3-8 210308-30597
==================
(1) 修改CRC16_X25计算CRC的问题。问题主要出在当有首位为1的字节(如，E9)就会由于符号问题导致计算错误。对此做了修改。首先设置指的时候通过 data[i] & 0x000000ff 来去掉byte的符号影响，然后，其他的计算均采用int型
(2) 增加CRC16_MODBUS类型CRC类，因为串口协议8使用的是这个类型
(3) 修改扫描3协议在打印流程当中，在收到empty事件，但没有下发数据（也不应该下发数据）时，对状态参数的修改，改为实际发生下发后才修改

2021-3-7 210307-30596
==================
追加串口协议8

2021-3-6 210306-30595
==================
30594版本遗漏部分（特别是仅仅判断9MM的地方）的补齐修改

2021-3-6 210306-30594
==================
追加E6X48和E6X50打印头类型。基础数据与9MM头一致，复制方法与R6X48和R6X50一致

2021-3-5 210305-30593
==================
(1) 在打印循环当中，判断isReady（QR文件到了最后）后，如果为false（已经到了终点），需要停止打印，并且要复位为true，否则后续打印均会失败，这个使原有打印流程的弊端，这个对于特殊数据源的判断放在了全局路径上。也可以在这再次判断是否为特殊路径需求。
(2) 取消purge的时候停止打印，完成后恢复打印的做法，改为原状态purge，结束以后设置回数据传输模式

2021-3-5 210305-30592
==================
取消DataTransferThread类中在打印状态下purge执行以后，重新下发打印数据的操作，由于purge操作结束以后，会重新启动打印作业，这是会收到empty事件，无需再次下发。但是按理即使再次下发也是更新操作，应该不会两次的内容链接起来，但是现在却发现有这个现象。正在打印123的时候，如果启动purge，在purge结束以后触发打印，会打出来123123。
但是，purge结束以后重新启动打印也有问题，就是会跳过purge执行前还没有下发的数据（这个数据会被覆盖掉）

2021-3-4 210304-30591
==================
解决QR.txt文件到了结尾以后不停止打印的问题。原因是以前在DataTask类中有一个isReady变量标记文件是否到了结尾，但是移到DataTransferThread类以后，该变量失效，必须在DataTransferThread类中启用类似变量进行管理。并且打印过程中参照新的变量控制打印流程

2021-3-4 210304-30590
==================
将读取QR.txt文件的操作移到next函数当中执行，当mIndex=0的时候读取。以前的位置是在获取empty之后去读的，会与首次下发读取的重叠读取，从而多读一行

2021-3-3 210303-30589
==================
当使用QR.txt作为DT和Barcode的数据来源时，需要一行内容对一个打印群组有效，以前是对一个打印任务有效，因此群组会出现跳行的问题。做了修改。
具体修改方法是，将在DataTask的refreshVariables函数里面完成的该功能移植到DataTransferThread类中执行，在打印过程中，只有当群组的开始时才
进行读取和设置。

2021-3-3 210303-30588
==================
修改开机打印启动方法，在线程中监视初始化状态完成情况

2021-3-2 210302-30587
==================
(1) 修改开机打印时墨水量处显示101--的问题
     - 将mRfid的初始值从100改为0
     - 使用疑似Rfid初始化成功标识mRfidInit，等待其为true时再启动打印
(2) 修改崩溃后原有预览不显示的问题
     - 疑似PreferenceConstants.LOADING_BEFORE_CRASH在恢复false前崩溃，导致不读取预览图，将loadMessage拿到!loading判断的外边

2021-3-1 210301-30586
==================
完善开机即打印功能的缺陷之处
(1) 将开机即打印调用移植延时线程，即等待界面显示成功再启动打印。最关键的是在此之前要执行loadMessage函数

2021-2-26 210226-30585
==================
取消30584版本中位移量参照bold进行调整的修改。恢复原样

2021-2-26 210226-30584
==================
(1) 将MessageTask类中的saveBinNoScale函数（保存1.bin）中重新生成位图createScaledBitmap函数的filter参数设为false，如果设为true，Bitmap类会对周边元素进行综合处理以使得图像更加圆滑，这样会使得图像的元素互相干扰
(2) 位移量参考bold打印参数，响应增大bold倍数的间距。即如果bold为300，则位移增加(300/150)倍数

2021-2-20 210220-30583
==================
(1) 讲PH7改为PI8，操作内容不变
(2) 修改DataTask当中生成Barcode打印缓冲区getPrintBitmap函数调用得getY参数，原来没有计算scale，疑似是个BUG
(3) 修改DataTask当中isNeedBuild函数当中对参数22和23的调用，原来错写为20和21，估计是修改遗漏

2021-2-5 210205-30582
==================
SC卡加墨时间，修改计时方法为每次睡眠100ms，循环检测时间是否到32秒

2021-2-5 210205-30581
==================
SC卡加墨时间间隔从2分钟改为30秒

2021-2-4 210204-30580
==================
追加打印软起动命令，通过网络发送接收

2021-2-3 210203-30579
==================
(1) refreshInk，墨量显示。墨盒的时候显示P1，P2，墨袋的时候显示B
(2) SmartCardManager墨袋使用真是的墨袋(BULK1)，取消墨盒代用的BULKX

2021-1-28 210128-30578
==================
(1) 将新增加的Kernel打印FpgaLog命令改在ControlTabActivity里面执行，如果放在FpgaGpioOperation里面做，可能会占用时间

2021-1-28 210128-30577
==================
(1) 取消30575和30576追加的LOG输出
(2) 增加FPGA命令，使得Kernel打印FPGA的输出Log
(3) 取消发送停止打印命令前的1秒等待

2021-1-27 210127-30576
==================
【临时版本】追加等待打印线程退出LOG

2021-1-27 210127-30575
==================
【临时版本】追加停止后各处理过程的LOG

2021-1-26 210126-30574
==================
为串口协议2追加清洗命令。格式为：7E 00 00 17 00 9F 3D 7F
在EC_DOD_Protocol和ControlTabActivity类中做相应修改。

2021-1-25 210125-30573
==================
解决使用高速触发器进行快速打印的时候，如果链接着触发器点击停止，就会死机的问题。
分析原因：因为是高速触发(1s20次触发)，在点按停止的时候，还会继续有数据传送，如果直接尝试关闭FPGA的驱动，可能会发生相互数据等待的问题。
解决方案：先停止apk方面的线程，待传递数据工作全面停止后，在停止FPGA的驱动
具体修改：
1. ControlTabActivity里面将响应MESSAGE_PRINT_STOP消息的处理中，将停止FPGA驱动调整到停止打印线程后执行
2. 在DataTransferThread里面追加一个标识打印线程停止的标记mStopped，当启动停止打印任务操作的时候，设置mRunning为false之后，等待mStopped为真才返回，这样可以保证在finish函数返回的时候，打印线程已经退出

2021-1-25 210125-30572
==================
改善快速打印性能。具体为：
1. 修改DataTransferThread当中的getInkThreshold函数，追加Threshold变量（与头数对应的数组），保存0号头的Threshold，当处于快速打印模式的时候，再次获取该值时，不再重新计算，直接返回该值。
2. 修改ControlTabActivity里的onCountChanged函数，将RTC的写入移到Message的Handler里面实现，同时增加清除未处理事件的功能，因为，此时这些堆积的事件处理也没有意义，只是占用CPU

* IMG在今日版本当中将FIFO数量增加到了20，APK的使用内存扩大1倍

2021-1-23 210123-30571
==================
【临时版本】
apk下发一个字节数据

2021-1-23 210123-30570
==================
【临时版本】
暂时取消打印线程当中其他的操作，仅保留在得到empty事件时，向驱动下发打既有印缓冲区数据。主要目的是测试数据传输过程当中是哪里占用时间。
因为1秒钟打印10次，每次间隔为100ms，而检测empty为间隔3ms，按理下发数据不消耗时间，但是数据跟不上，根据log，write函数居然用时30ms，即使这样也应该跟的上，具体原因不明，本版本的目的是逐步厘清哪里耗时

2021-1-21 210121-30569
==================
1. 更新7号字体，希腊文改善
2. 追加9mm打印头。
    2-1 在PrinterNozzle里面追加MESSAGE_TYPE_9MM，同时修改该类中与该类打印头相对应的参数；
    2-2 同时修改其他类中对该类型的使用部分；
    2-3 在MessageObject中增加适合9mm打印头的固定长度数组，以及一些特殊处理

2021-1-17 210117-30568
==================
扫描协议3，打印管理策略的修改
1. 开始打印时，以及收到empty事件（驱动申请数据）时，不下发数据，以前的实现仅在开始打印的时候不下发数据，收到empty事件的时候，会根据情况下发或者不下发数据
2. 在收到empty事件以后，虽然不实际下发数据，但是，如果mIndex小于任务数量，并且大于0（即，处于群组处理的过程当中），设置mNeedUpdate标识，导致更新打印缓冲区的生成，以达到一次扫描群组当中所有任务有效的目的。但是，其他的群组，或者无群组的单独任务的情况下，则没有任何缓冲区数据下发。
3. 因此，取消mScaner3DataPrinted标识
4. 追加dataSent标识，这个标识的主要目的是防止群组打印的时候刚刚进入就加1，导致群组的第一个任务不被打印的问题。对其他数据源的打印没有影响

2021-1-15 210115-30567
==================
追加扫描协议3，协议内容与扫描协议2完全一致，只是扫描协议3的数据仅允许打印一次
1. 在SystemConfigFile当中追加扫描协议3标识变量，DATA_SOURCE_SCANER3
2. 在serialHandler当中追加对应于扫描协议3的入口处理，完全承袭扫描协议2
3. 在DataTransferThread当中，追加已打印标志mScaner3DataPrinted。对于扫描协议3，该变量处理逻辑为：
    3-1 开始打印时，其值为true。以假的已经打印标识阻止开始阶段的强制下发打印缓冲区
    3-2 当接收到扫描数据后，在向相应的变量设置了新的内容之后，将其值设为false
    3-3 当pollState返回非0非-1时（由于初始没有下发数据，最初会始终的到该值），如果mScaner3DataPrinted为false，则生成打印缓冲区下发，如果为true，直接回到pollState（睡眠30ms），下发数据后，将mScaner3DataPrinted设为true
4. 其他数据源的情况下，不考虑mScaner3DataPrinted的值，不影响初始状态下的强制下发，pollState之后的下发

2021-1-11 210111-30566
==================
(解决QR.txt打印不全的问题，分析原因是还没有打印完成就发送了Clean)
1. 取消点按停止打印后下发参数的操作，应该没有必要（ControlTabActivity的MESSAGE_PRINT_STOP消息响应）
2. 取消点按停止打印后下发CLEAN的操作，应该没有必要（ControlTabActivity的MESSAGE_PRINT_STOP消息响应）
3. 在下发停止命令之前睡眠1s，以保证正在打印的任务能够完成，但是这个方法是一个近似方法，不能保证绝对没问题（FpgaGpioOperation)

2021-1-10 210110-30565
==================
1. 修改QR_R.txt文件条目全部打印完成后不停止打印的问题。
    原因是，如果打印完成，如果QRReader不能从QR_R.txt当中读到数据的时候，将DataTask的isReady设为false，这部分代码未从Barcode处理的部分移到新的位置
	--------------------------------------
	if (TextUtils.isEmpty(content)) {
		isReady = false;
		return;
	}
	--------------------------------------
    （通过这个方式传递QR文件的结尾，逻辑上太粗糙了。大的逻辑应该是，每次生成打印缓冲区，DataTask要给一个大的成功/失败的结果，并且能够给出细致的原因，然后调用者根据出错的原因采取相应的对策。）

2021-1-9 210109-30564
==================
1. 调整初始化状态和有效状态的使用
    1-1 初始状态为：初始化状态标记为[未初始化-false]，有效性标记未[有效-true]
          在未被初始化的情况下，设备是否有效还不确定，此时如果设为false，是对未知状态的错误断定，会导致报警，暂时设为true，待后续确定。
          （因为主页面墨量信息显示会早于初始化完成进行，因此，必须保持有效，否则会报警）
    1-2 初始化成功时：初始化状态标记为[初始化-true]，有效性标记未[有效-true]
          此为正常使用状态
    1-3 初始化失败时：初始化状态标记为[未初始化-false]，有效性标记未[无效-false]
          初始化失败，禁止使用
    1-4 运行时失败（如访问错误，一致性检测失败或OIB等）：初始化状态标记为[初始化-true]，有效性标记未[无效-false]
          设备不正常，禁止使用
2. 获取墨量函数返回值策略
    2-1 墨量值为-1
        此时，设备还未曾做过任何初始化，因此墨量值为未知，不见得是有问题，因此返回100
    2-2 墨量值不为-1
        此时，设备已经被初始化，并且读取过正确数值，至少一次，返回具体值
3. 获取有效性策略
    直接返回有效性值。

2021-1-8 210108K-30563
==================
1. 对于从LEVEL读到的值，如果不在有效范围内（120，160）则不收录
2. 加墨10次后墨盒的墨位仍然在135一下，则停止打印，报警。如果墨袋的剩余量不足5%，则将墨袋的OIB置位（确认）

2021-1-8 210108J-30562
==================
1. 将updateLevel函数中的防止再进入锁取消，进队加墨操作加入再入排斥锁（levelValueUpdated函数中另起线程，加锁）

2021-1-8 210108H-30560
==================
1. 墨位信息显示优化
2. updateLevel线程锁定义为volatile

2021-1-8 210108G-30559
==================
1. 加墨进入锁，次数和失败标记从全局变量更改为每个单元独立变量，独立管理，独立显示

2021-1-8 210108F-30558
==================
1. 修改加墨次数显示逻辑判断BUG

2021-1-8 210108E-30557
==================
1. 增加10次平均LEVEL值LOG输出，已确认是否得到进入加墨操作条件

2021-1-8 210108D-30556
==================
1. SC单元管理表在SmartCardManager实例生成时生成。即，该管理表在开机过程中始终有效，并且不能更改，因此在运行途中不可更换SC单元（墨盒，墨袋或者LEVEL）
2. getLocalInkPercentage函数在该单元mValid的时候返回实际值，否则返回100f。目的是保证即使关闭打印，也会提供上次的只作为显示依据（关闭打印时仅标记mInitialized为false，但mValid仍未原来值），getLocalInkPercentage只要时mValid即返回实际值，这样就保证了返回的值是截止到上次的最新值。
3. SC单元信息显示，记载初始化后每一分钟轮换一次显示（墨盒和墨袋），以后不再显示。
4. 增加读取LEVEL值的入口处（updateLevel函数）的LOG输出。

2021-1-8 210108C-30555
==================
1. 修改初始化顺序，先初始化LEVEL

2021-1-8 210108B-30554
==================
1. 修改加墨函数addInkOn的判断逻辑，原逻辑存在错误（cardIdx索引直接与卡类型(PEN1等)匹配了)

2021-1-8 210108-30553
==================
1. 修改SmartCardManager的getLocalInkPercentage函数，在相应单元还没有初始化的时候返回100f。因为初始化比较慢，在这之前显示部分就会来获取百分比，此时百分比=0，因此会导致报警
2. 修改SmartCardManager的isValid函数，在相应单元还没有初始化的时候返回true。因为初始化比较慢，在这之前显示部分就会来获取该参数，此时为false，因此会导致报警

2021-1-8 1911150108-30552
==================
1. 取消掉BaseObject当中timeDelay函数里面的Debug.d(TAG, "--->delay:" + delay);log输出，在实时时间变量的时候，这个log频繁输出，影响调试
2. 在ControlTabActivity当中的refreshInk函数里面增加log输出，已确认模量显示信息
3. 恢复在DataTask的refreshVariables函数里面，2020-10-29日修改的对scaleW，scaleH以及div的修改，因为这个修改可能导致12.7系列喷头生成打印缓冲区不正常。原来的代码当中，如果是12.7系列的头，scaleW和div成倍数关系，但是其他的头确实相等关系，具体原因需要后续调查。后来的修改都是相等关系，因此会导致生成打印缓冲区的时候内存溢出。

2021-1-7 1911150107D-30551
==================
1. 将SmartCardManager中显示LEVEL值时，LEVEL序号显示错误修正
2. ControlTabActivity当中的头数从固定数字3，改为根据头的类型获取（仅限Smart'Card时）
3. 将SC单元的生成移植初始化执行阶段，这样，喷头类型可以在打印前进行更换。
4. LEVEL的初始化成功以后，与配合墨盒的初始化结果&&，保证两者都通过才算通过
5. SmartCard关闭时，将当前单元的初始化标记改为false，以防止继续向硬件发起访问，但保留valid有效，以使得页面能够继续显示前次的Ink状态

2021-1-7 1911150107C-30550
==================
1. 将SmartCardManager中读取LEVEL值的操作从原来的读取当前选定喷头的LEVEL，改为主动循环读取所有头的LEVEL值，并且显示全部

2021-1-7 1911150107B-30549
==================
1. 将SmartCard库(libsmartcard.so)中的通路选择部分的PEN2和BULK对调，目的是测试LEVEL接续是否正确

2021-1-7 1911150107A-30548
==================
1. 修改SmartCardManager内部类的mValid初始值和初始化成功后的值设置反了的错误

2021-1-7 1911150107-30547
==================
1. 修改参数56的标题，英文为：FIFO，中文为：打印缓存
2. 在FpgaGpioOperation.java当中追加一个getPrintedCount函数，用来获取从开始打印到当前为止已经打印的数量（向Fpga下发的次数）
3. 修改SmartCardManager的策略
    3.1 开机首次初始化时，无论实际成功与否均返回成功，但每个墨盒/墨袋的初始化状态分别记忆，如果有不成功的情况，将在refreshInk当中进行具体显示，并且，如果有未成功的单元，则禁止打印
    3.2 点按打印后的初始化时，如果有未成功的单元，则返回MSG_SMARTCARD_CHECK_FAILED，停止打印。
    3.3 取消错误码显示机制，该机制仅为调试使用
    3.4 墨量显示时，墨袋表示由“B”改为大于墨盒数量的数字

2021-1-6 1911150106B-30546
==================
1. 根据参数31(喷头类型)，如果是12.7x2类型则认定墨盒有两个，其他则认为墨盒有一个，墨袋固定为一个
2. 支持可变墨盒数量及（未来可能的可变）墨袋数量的SC卡读写，控制和信息显示功能

2021-1-6 1911150106A-30545
==================
1. 恢复30544版本取消的墨位范围限制
2. 恢复30544版本取消的加墨操作
3. 加墨开关打开时间从200ms改为100ms

2021-1-6 1911150106-30544
==================
1.  暂时取消墨位范围限制。原限制逻辑为在12000000, 16000000之间认定为正常，否则为数值异常，不做处理
2.  暂时取消加墨操作，待具体数值确认清楚后再定
